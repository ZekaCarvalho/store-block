(function (factory) {
	typeof define === 'function' && define.amd ? define(factory) :
	factory();
}((function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	/* eslint complexity: [2, 18], max-statements: [2, 33] */
	var shams = function hasSymbols() {
		if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
		if (typeof Symbol.iterator === 'symbol') { return true; }

		var obj = {};
		var sym = Symbol('test');
		var symObj = Object(sym);
		if (typeof sym === 'string') { return false; }

		if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
		if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

		// temp disabled per https://github.com/ljharb/object.assign/issues/17
		// if (sym instanceof Symbol) { return false; }
		// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
		// if (!(symObj instanceof Symbol)) { return false; }

		// if (typeof Symbol.prototype.toString !== 'function') { return false; }
		// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

		var symVal = 42;
		obj[sym] = symVal;
		for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
		if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

		if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) { return false; }

		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

		if (typeof Object.getOwnPropertyDescriptor === 'function') {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
		}

		return true;
	};

	var origSymbol = commonjsGlobal.Symbol;


	var hasSymbols = function hasNativeSymbols() {
		if (typeof origSymbol !== 'function') { return false; }
		if (typeof Symbol !== 'function') { return false; }
		if (typeof origSymbol('foo') !== 'symbol') { return false; }
		if (typeof Symbol('bar') !== 'symbol') { return false; }

		return shams();
	};

	/* eslint no-invalid-this: 1 */

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var slice = Array.prototype.slice;
	var toStr = Object.prototype.toString;
	var funcType = '[object Function]';

	var implementation = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slice.call(arguments, 1);

	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                args.concat(slice.call(arguments))
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        } else {
	            return target.apply(
	                that,
	                args.concat(slice.call(arguments))
	            );
	        }
	    };

	    var boundLength = Math.max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs.push('$' + i);
	    }

	    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};

	var functionBind = Function.prototype.bind || implementation;

	/* globals
		Atomics,
		SharedArrayBuffer,
	*/

	var undefined$1;

	var $TypeError = TypeError;

	var $gOPD = Object.getOwnPropertyDescriptor;
	if ($gOPD) {
		try {
			$gOPD({}, '');
		} catch (e) {
			$gOPD = null; // this is IE 8, which has a broken gOPD
		}
	}

	var throwTypeError = function () { throw new $TypeError(); };
	var ThrowTypeError = $gOPD
		? (function () {
			try {
				// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
				arguments.callee; // IE 8 does not throw here
				return throwTypeError;
			} catch (calleeThrows) {
				try {
					// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
					return $gOPD(arguments, 'callee').get;
				} catch (gOPDthrows) {
					return throwTypeError;
				}
			}
		}())
		: throwTypeError;

	var hasSymbols$1 = hasSymbols();

	var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto
	var generatorFunction =  undefined$1;
	var asyncFunction =  undefined$1;
	var asyncGenFunction =  undefined$1;

	var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto(Uint8Array);

	var INTRINSICS = {
		'%Array%': Array,
		'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
		'%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer.prototype,
		'%ArrayIteratorPrototype%': hasSymbols$1 ? getProto([][Symbol.iterator]()) : undefined$1,
		'%ArrayPrototype%': Array.prototype,
		'%ArrayProto_entries%': Array.prototype.entries,
		'%ArrayProto_forEach%': Array.prototype.forEach,
		'%ArrayProto_keys%': Array.prototype.keys,
		'%ArrayProto_values%': Array.prototype.values,
		'%AsyncFromSyncIteratorPrototype%': undefined$1,
		'%AsyncFunction%': asyncFunction,
		'%AsyncFunctionPrototype%':  undefined$1,
		'%AsyncGenerator%':  undefined$1,
		'%AsyncGeneratorFunction%': asyncGenFunction,
		'%AsyncGeneratorPrototype%':  undefined$1,
		'%AsyncIteratorPrototype%':  undefined$1,
		'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
		'%Boolean%': Boolean,
		'%BooleanPrototype%': Boolean.prototype,
		'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
		'%DataViewPrototype%': typeof DataView === 'undefined' ? undefined$1 : DataView.prototype,
		'%Date%': Date,
		'%DatePrototype%': Date.prototype,
		'%decodeURI%': decodeURI,
		'%decodeURIComponent%': decodeURIComponent,
		'%encodeURI%': encodeURI,
		'%encodeURIComponent%': encodeURIComponent,
		'%Error%': Error,
		'%ErrorPrototype%': Error.prototype,
		'%eval%': eval, // eslint-disable-line no-eval
		'%EvalError%': EvalError,
		'%EvalErrorPrototype%': EvalError.prototype,
		'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
		'%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array.prototype,
		'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
		'%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array.prototype,
		'%Function%': Function,
		'%FunctionPrototype%': Function.prototype,
		'%Generator%':  undefined$1,
		'%GeneratorFunction%': generatorFunction,
		'%GeneratorPrototype%':  undefined$1,
		'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
		'%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array.prototype,
		'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
		'%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined$1 : Int8Array.prototype,
		'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
		'%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array.prototype,
		'%isFinite%': isFinite,
		'%isNaN%': isNaN,
		'%IteratorPrototype%': hasSymbols$1 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
		'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
		'%JSONParse%': typeof JSON === 'object' ? JSON.parse : undefined$1,
		'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
		'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
		'%MapPrototype%': typeof Map === 'undefined' ? undefined$1 : Map.prototype,
		'%Math%': Math,
		'%Number%': Number,
		'%NumberPrototype%': Number.prototype,
		'%Object%': Object,
		'%ObjectPrototype%': Object.prototype,
		'%ObjProto_toString%': Object.prototype.toString,
		'%ObjProto_valueOf%': Object.prototype.valueOf,
		'%parseFloat%': parseFloat,
		'%parseInt%': parseInt,
		'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
		'%PromisePrototype%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype,
		'%PromiseProto_then%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype.then,
		'%Promise_all%': typeof Promise === 'undefined' ? undefined$1 : Promise.all,
		'%Promise_reject%': typeof Promise === 'undefined' ? undefined$1 : Promise.reject,
		'%Promise_resolve%': typeof Promise === 'undefined' ? undefined$1 : Promise.resolve,
		'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
		'%RangeError%': RangeError,
		'%RangeErrorPrototype%': RangeError.prototype,
		'%ReferenceError%': ReferenceError,
		'%ReferenceErrorPrototype%': ReferenceError.prototype,
		'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
		'%RegExp%': RegExp,
		'%RegExpPrototype%': RegExp.prototype,
		'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
		'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
		'%SetPrototype%': typeof Set === 'undefined' ? undefined$1 : Set.prototype,
		'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
		'%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer.prototype,
		'%String%': String,
		'%StringIteratorPrototype%': hasSymbols$1 ? getProto(''[Symbol.iterator]()) : undefined$1,
		'%StringPrototype%': String.prototype,
		'%Symbol%': hasSymbols$1 ? Symbol : undefined$1,
		'%SymbolPrototype%': hasSymbols$1 ? Symbol.prototype : undefined$1,
		'%SyntaxError%': SyntaxError,
		'%SyntaxErrorPrototype%': SyntaxError.prototype,
		'%ThrowTypeError%': ThrowTypeError,
		'%TypedArray%': TypedArray,
		'%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined$1,
		'%TypeError%': $TypeError,
		'%TypeErrorPrototype%': $TypeError.prototype,
		'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
		'%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array.prototype,
		'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
		'%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray.prototype,
		'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
		'%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array.prototype,
		'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
		'%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array.prototype,
		'%URIError%': URIError,
		'%URIErrorPrototype%': URIError.prototype,
		'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
		'%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap.prototype,
		'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,
		'%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet.prototype
	};


	var $replace = functionBind.call(Function.call, String.prototype.replace);

	/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
	var stringToPath = function stringToPath(string) {
		var result = [];
		$replace(string, rePropName, function (match, number, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : (number || match);
		});
		return result;
	};
	/* end adaptation */

	var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
		if (!(name in INTRINSICS)) {
			throw new SyntaxError('intrinsic ' + name + ' does not exist!');
		}

		// istanbul ignore if // hopefully this is impossible to test :-)
		if (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return INTRINSICS[name];
	};

	var GetIntrinsic = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== 'string' || name.length === 0) {
			throw new TypeError('intrinsic name must be a non-empty string');
		}
		if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
			throw new TypeError('"allowMissing" argument must be a boolean');
		}

		var parts = stringToPath(name);

		var value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);
		for (var i = 1; i < parts.length; i += 1) {
			if (value != null) {
				if ($gOPD && (i + 1) >= parts.length) {
					var desc = $gOPD(value, parts[i]);
					if (!allowMissing && !(parts[i] in value)) {
						throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
					}
					value = desc ? (desc.get || desc.value) : value[parts[i]];
				} else {
					value = value[parts[i]];
				}
			}
		}
		return value;
	};

	var $String = GetIntrinsic('%String%');
	var $TypeError$1 = GetIntrinsic('%TypeError%');

	// https://www.ecma-international.org/ecma-262/6.0/#sec-tostring

	var ToString = function ToString(argument) {
		if (typeof argument === 'symbol') {
			throw new $TypeError$1('Cannot convert a Symbol value to a string');
		}
		return $String(argument);
	};

	/**
	 * https://tc39.es/ecma402/#sec-getoption
	 * @param opts
	 * @param prop
	 * @param type
	 * @param values
	 * @param fallback
	 */
	function GetOption(opts, prop, type, values, fallback) {
	    // const descriptor = Object.getOwnPropertyDescriptor(opts, prop);
	    var value = opts[prop];
	    if (value !== undefined) {
	        if (type !== 'boolean' && type !== 'string') {
	            throw new TypeError('invalid type');
	        }
	        if (type === 'boolean') {
	            value = Boolean(value);
	        }
	        if (type === 'string') {
	            value = ToString(value);
	        }
	        if (values !== undefined && !values.filter(function (val) { return val == value; }).length) {
	            throw new RangeError(value + " is not within " + values.join(', '));
	        }
	        return value;
	    }
	    return fallback;
	}

	var _isNaN = Number.isNaN || function isNaN(a) {
		return a !== a;
	};

	/**
	 * Cannot do Math.log(x) / Math.log(10) bc if IEEE floating point issue
	 * @param x number
	 */
	function setInternalSlot(map, pl, field, value) {
	    if (!map.get(pl)) {
	        map.set(pl, Object.create(null));
	    }
	    var slots = map.get(pl);
	    slots[field] = value;
	}
	function getInternalSlot(map, pl, field) {
	    return getMultiInternalSlots(map, pl, field)[field];
	}
	function getMultiInternalSlots(map, pl) {
	    var fields = [];
	    for (var _i = 2; _i < arguments.length; _i++) {
	        fields[_i - 2] = arguments[_i];
	    }
	    var slots = map.get(pl);
	    if (!slots) {
	        throw new TypeError(pl + " InternalSlot has not been initialized");
	    }
	    return fields.reduce(function (all, f) {
	        all[f] = slots[f];
	        return all;
	    }, Object.create(null));
	}
	function isLiteralPart(patternPart) {
	    return patternPart.type === 'literal';
	}
	var UNICODE_EXTENSION_SEQUENCE_REGEX = /-u(?:-[0-9a-z]{2,8})+/gi;
	function invariant(condition, message, Err) {
	    if (Err === void 0) { Err = Error; }
	    if (!condition) {
	        throw new Err(message);
	    }
	}

	/**
	 * https://tc39.es/ecma402/#sec-partitionpattern
	 * @param pattern
	 */
	function PartitionPattern(pattern) {
	    var result = [];
	    var beginIndex = pattern.indexOf('{');
	    var endIndex = 0;
	    var nextIndex = 0;
	    var length = pattern.length;
	    while (beginIndex < pattern.length && beginIndex > -1) {
	        endIndex = pattern.indexOf('}', beginIndex);
	        invariant(endIndex > beginIndex, "Invalid pattern " + pattern);
	        if (beginIndex > nextIndex) {
	            result.push({
	                type: 'literal',
	                value: pattern.substring(nextIndex, beginIndex),
	            });
	        }
	        result.push({
	            type: pattern.substring(beginIndex + 1, endIndex),
	            value: undefined,
	        });
	        nextIndex = endIndex + 1;
	        beginIndex = pattern.indexOf('{', nextIndex);
	    }
	    if (nextIndex < length) {
	        result.push({
	            type: 'literal',
	            value: pattern.substring(nextIndex, length),
	        });
	    }
	    return result;
	}

	/**
	 * https://tc39.es/ecma402/#sec-bestavailablelocale
	 * @param availableLocales
	 * @param locale
	 */
	function BestAvailableLocale(availableLocales, locale) {
	    var candidate = locale;
	    while (true) {
	        if (~availableLocales.indexOf(candidate)) {
	            return candidate;
	        }
	        var pos = candidate.lastIndexOf('-');
	        if (!~pos) {
	            return undefined;
	        }
	        if (pos >= 2 && candidate[pos - 2] === '-') {
	            pos -= 2;
	        }
	        candidate = candidate.slice(0, pos);
	    }
	}

	/**
	 * https://tc39.es/ecma402/#sec-lookupmatcher
	 * @param availableLocales
	 * @param requestedLocales
	 * @param getDefaultLocale
	 */
	function LookupMatcher(availableLocales, requestedLocales, getDefaultLocale) {
	    var result = { locale: '' };
	    for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
	        var locale = requestedLocales_1[_i];
	        var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
	        var availableLocale = BestAvailableLocale(availableLocales, noExtensionLocale);
	        if (availableLocale) {
	            result.locale = availableLocale;
	            if (locale !== noExtensionLocale) {
	                result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);
	            }
	            return result;
	        }
	    }
	    result.locale = getDefaultLocale();
	    return result;
	}

	/**
	 * https://tc39.es/ecma402/#sec-bestfitmatcher
	 * @param availableLocales
	 * @param requestedLocales
	 * @param getDefaultLocale
	 */
	function BestFitMatcher(availableLocales, requestedLocales, getDefaultLocale) {
	    var result = { locale: '' };
	    for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
	        var locale = requestedLocales_1[_i];
	        var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
	        var availableLocale = BestAvailableLocale(availableLocales, noExtensionLocale);
	        if (availableLocale) {
	            result.locale = availableLocale;
	            if (locale !== noExtensionLocale) {
	                result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);
	            }
	            return result;
	        }
	    }
	    result.locale = getDefaultLocale();
	    return result;
	}

	/**
	 * https://tc39.es/ecma402/#sec-unicodeextensionvalue
	 * @param extension
	 * @param key
	 */
	function UnicodeExtensionValue(extension, key) {
	    invariant(key.length === 2, 'key must have 2 elements');
	    var size = extension.length;
	    var searchValue = "-" + key + "-";
	    var pos = extension.indexOf(searchValue);
	    if (pos !== -1) {
	        var start = pos + 4;
	        var end = start;
	        var k = start;
	        var done = false;
	        while (!done) {
	            var e = extension.indexOf('-', k);
	            var len = void 0;
	            if (e === -1) {
	                len = size - k;
	            }
	            else {
	                len = e - k;
	            }
	            if (len === 2) {
	                done = true;
	            }
	            else if (e === -1) {
	                end = size;
	                done = true;
	            }
	            else {
	                end = e;
	                k = e + 1;
	            }
	        }
	        return extension.slice(start, end);
	    }
	    searchValue = "-" + key;
	    pos = extension.indexOf(searchValue);
	    if (pos !== -1 && pos + 3 === size) {
	        return '';
	    }
	    return undefined;
	}

	/**
	 * https://tc39.es/ecma402/#sec-resolvelocale
	 */
	function ResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData, getDefaultLocale) {
	    var matcher = options.localeMatcher;
	    var r;
	    if (matcher === 'lookup') {
	        r = LookupMatcher(availableLocales, requestedLocales, getDefaultLocale);
	    }
	    else {
	        r = BestFitMatcher(availableLocales, requestedLocales, getDefaultLocale);
	    }
	    var foundLocale = r.locale;
	    var result = { locale: '', dataLocale: foundLocale };
	    var supportedExtension = '-u';
	    for (var _i = 0, relevantExtensionKeys_1 = relevantExtensionKeys; _i < relevantExtensionKeys_1.length; _i++) {
	        var key = relevantExtensionKeys_1[_i];
	        var foundLocaleData = localeData[foundLocale];
	        invariant(typeof foundLocaleData === 'object' && foundLocaleData !== null, "locale data " + key + " must be an object");
	        var keyLocaleData = foundLocaleData[key];
	        invariant(Array.isArray(keyLocaleData), "keyLocaleData for " + key + " must be an array");
	        var value = keyLocaleData[0];
	        invariant(typeof value === 'string' || value === null, "value must be string or null but got " + typeof value + " in key " + key);
	        var supportedExtensionAddition = '';
	        if (r.extension) {
	            var requestedValue = UnicodeExtensionValue(r.extension, key);
	            if (requestedValue !== undefined) {
	                if (requestedValue !== '') {
	                    if (~keyLocaleData.indexOf(requestedValue)) {
	                        value = requestedValue;
	                        supportedExtensionAddition = "-" + key + "-" + value;
	                    }
	                }
	                else if (~requestedValue.indexOf('true')) {
	                    value = 'true';
	                    supportedExtensionAddition = "-" + key;
	                }
	            }
	        }
	        if (key in options) {
	            var optionsValue = options[key];
	            invariant(typeof optionsValue === 'string' ||
	                typeof optionsValue === 'undefined' ||
	                optionsValue === null, 'optionsValue must be String, Undefined or Null');
	            if (~keyLocaleData.indexOf(optionsValue)) {
	                if (optionsValue !== value) {
	                    value = optionsValue;
	                    supportedExtensionAddition = '';
	                }
	            }
	        }
	        result[key] = value;
	        supportedExtension += supportedExtensionAddition;
	    }
	    if (supportedExtension.length > 2) {
	        var privateIndex = foundLocale.indexOf('-x-');
	        if (privateIndex === -1) {
	            foundLocale = foundLocale + supportedExtension;
	        }
	        else {
	            var preExtension = foundLocale.slice(0, privateIndex);
	            var postExtension = foundLocale.slice(privateIndex, foundLocale.length);
	            foundLocale = preExtension + supportedExtension + postExtension;
	        }
	        foundLocale = Intl.getCanonicalLocales(foundLocale)[0];
	    }
	    result.locale = foundLocale;
	    return result;
	}

	var $TypeError$2 = GetIntrinsic('%TypeError%');

	// http://www.ecma-international.org/ecma-262/5.1/#sec-9.10

	var CheckObjectCoercible = function CheckObjectCoercible(value, optMessage) {
		if (value == null) {
			throw new $TypeError$2(optMessage || ('Cannot call method on ' + value));
		}
		return value;
	};

	var RequireObjectCoercible = CheckObjectCoercible;

	var $Object = GetIntrinsic('%Object%');



	// https://www.ecma-international.org/ecma-262/6.0/#sec-toobject

	var ToObject = function ToObject(value) {
		RequireObjectCoercible(value);
		return $Object(value);
	};

	/**
	 * https://tc39.es/ecma402/#sec-lookupsupportedlocales
	 * @param availableLocales
	 * @param requestedLocales
	 */
	function LookupSupportedLocales(availableLocales, requestedLocales) {
	    var subset = [];
	    for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
	        var locale = requestedLocales_1[_i];
	        var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
	        var availableLocale = BestAvailableLocale(availableLocales, noExtensionLocale);
	        if (availableLocale) {
	            subset.push(availableLocale);
	        }
	    }
	    return subset;
	}

	/**
	 * https://tc39.es/ecma402/#sec-supportedlocales
	 * @param availableLocales
	 * @param requestedLocales
	 * @param options
	 */
	function SupportedLocales(availableLocales, requestedLocales, options) {
	    var matcher = 'best fit';
	    if (options !== undefined) {
	        options = ToObject(options);
	        matcher = GetOption(options, 'localeMatcher', 'string', ['lookup', 'best fit'], 'best fit');
	    }
	    if (matcher === 'best fit') {
	        return LookupSupportedLocales(availableLocales, requestedLocales);
	    }
	    return LookupSupportedLocales(availableLocales, requestedLocales);
	}

	var __extends = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (undefined && undefined.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	function getLocaleHierarchy(locale) {
	    var results = [locale];
	    var localeParts = locale.split('-');
	    for (var i = localeParts.length; i > 1; i--) {
	        results.push(localeParts.slice(0, i - 1).join('-'));
	    }
	    return results;
	}
	var MissingLocaleDataError = /** @class */ (function (_super) {
	    __extends(MissingLocaleDataError, _super);
	    function MissingLocaleDataError() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.type = 'MISSING_LOCALE_DATA';
	        return _this;
	    }
	    return MissingLocaleDataError;
	}(Error));
	function isMissingLocaleDataError(e) {
	    return e.type === 'MISSING_LOCALE_DATA';
	}
	function unpackData(locale, localeData, 
	/** By default shallow merge the dictionaries. */
	reducer) {
	    if (reducer === void 0) { reducer = function (all, d) { return (__assign(__assign({}, all), d)); }; }
	    var localeHierarchy = getLocaleHierarchy(locale);
	    var dataToMerge = localeHierarchy
	        .map(function (l) { return localeData.data[l]; })
	        .filter(Boolean);
	    if (!dataToMerge.length) {
	        throw new MissingLocaleDataError("Missing locale data for \"" + locale + "\", lookup hierarchy: " + localeHierarchy.join(', '));
	    }
	    dataToMerge.reverse();
	    return dataToMerge.reduce(reducer, {});
	}

	// http://www.ecma-international.org/ecma-262/5.1/#sec-9.12

	var SameValue = function SameValue(x, y) {
		if (x === y) { // 0 === -0, but they are not identical.
			if (x === 0) { return 1 / x === 1 / y; }
			return true;
		}
		return _isNaN(x) && _isNaN(y);
	};

	/**
	 * https://tc39.es/proposal-intl-relative-time/#sec-singularrelativetimeunit
	 * @param unit
	 */
	function singularRelativeTimeUnit(unit) {
	    invariant(typeof unit === 'string', "unit must be a string, instead got " + typeof unit, TypeError);
	    if (unit === 'seconds')
	        return 'second';
	    if (unit === 'minutes')
	        return 'minute';
	    if (unit === 'hours')
	        return 'hour';
	    if (unit === 'days')
	        return 'day';
	    if (unit === 'weeks')
	        return 'week';
	    if (unit === 'months')
	        return 'month';
	    if (unit === 'quarters')
	        return 'quarter';
	    if (unit === 'years')
	        return 'year';
	    if (unit !== 'second' &&
	        unit !== 'minute' &&
	        unit !== 'hour' &&
	        unit !== 'day' &&
	        unit !== 'week' &&
	        unit !== 'month' &&
	        unit !== 'quarter' &&
	        unit !== 'year') {
	        throw new RangeError("Invalid unit " + unit);
	    }
	    return unit;
	}
	var NUMBERING_SYSTEM_REGEX = /^[a-z0-9]{3,8}(-[a-z0-9]{3,8})*$/i;
	/**
	 * https://tc39.es/proposal-intl-relative-time/#sec-makepartslist
	 * @param pattern
	 * @param unit
	 * @param parts
	 */
	function makePartsList(pattern, unit, parts) {
	    var patternParts = PartitionPattern(pattern);
	    var result = [];
	    for (var _i = 0, patternParts_1 = patternParts; _i < patternParts_1.length; _i++) {
	        var patternPart = patternParts_1[_i];
	        if (isLiteralPart(patternPart)) {
	            result.push({
	                type: 'literal',
	                value: patternPart.value,
	            });
	        }
	        else {
	            invariant(patternPart.type === '0', "Malformed pattern " + pattern);
	            for (var _a = 0, parts_1 = parts; _a < parts_1.length; _a++) {
	                var part = parts_1[_a];
	                result.push({
	                    type: part.type,
	                    value: part.value,
	                    unit: unit,
	                });
	            }
	        }
	    }
	    return result;
	}
	/**
	 * PartitionRelativeTimePattern
	 * @param rtf
	 * @param value
	 * @param unit
	 */
	function partitionRelativeTimePattern(internalSlotMap, rtf, value, unit) {
	    invariant(typeof value === 'number', "value must be number, instead got " + typeof value, TypeError);
	    invariant(typeof unit === 'string', "unit must be number, instead got " + typeof value, TypeError);
	    if (isNaN(value) || value === Infinity || value === -Infinity) {
	        throw new RangeError("Invalid value " + value);
	    }
	    var resolvedUnit = singularRelativeTimeUnit(unit);
	    var fields = getInternalSlot(internalSlotMap, rtf, 'fields');
	    var style = getInternalSlot(internalSlotMap, rtf, 'style');
	    var entry = resolvedUnit;
	    if (style === 'short') {
	        entry = resolvedUnit + "-short";
	    }
	    else if (style === 'narrow') {
	        entry = resolvedUnit + "-narrow";
	    }
	    if (!(entry in fields)) {
	        entry = resolvedUnit;
	    }
	    var patterns = fields[entry];
	    var numeric = getInternalSlot(internalSlotMap, rtf, 'numeric');
	    if (numeric === 'auto') {
	        if (ToString(value) in patterns) {
	            return [
	                {
	                    type: 'literal',
	                    value: patterns[ToString(value)],
	                },
	            ];
	        }
	    }
	    var tl = 'future';
	    if (SameValue(value, -0) || value < 0) {
	        tl = 'past';
	    }
	    var po = patterns[tl];
	    var pluralRules = getInternalSlot(internalSlotMap, rtf, 'pluralRules');
	    var numberFormat = getInternalSlot(internalSlotMap, rtf, 'numberFormat');
	    var fv = typeof numberFormat.formatToParts === 'function'
	        ? numberFormat.formatToParts(Math.abs(value))
	        : // TODO: If formatToParts is not supported, we assume the whole formatted
	            // number is a part
	            [
	                {
	                    type: 'literal',
	                    value: numberFormat.format(Math.abs(value)),
	                    unit: unit,
	                },
	            ];
	    var pr = pluralRules.select(value);
	    var pattern = po[pr];
	    return makePartsList(pattern, resolvedUnit, fv);
	}
	var RelativeTimeFormat = /** @class */ (function () {
	    function RelativeTimeFormat(locales, options) {
	        // test262/test/intl402/RelativeTimeFormat/constructor/constructor/newtarget-undefined.js
	        // Cannot use `new.target` bc of IE11 & TS transpiles it to something else
	        var newTarget = this && this instanceof RelativeTimeFormat ? this.constructor : void 0;
	        if (!newTarget) {
	            throw new TypeError("Intl.RelativeTimeFormat must be called with 'new'");
	        }
	        setInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'initializedRelativeTimeFormat', true);
	        var requestedLocales = Intl
	            .getCanonicalLocales(locales);
	        var opt = Object.create(null);
	        var opts = options === undefined ? Object.create(null) : ToObject(options);
	        var matcher = GetOption(opts, 'localeMatcher', 'string', ['best fit', 'lookup'], 'best fit');
	        opt.localeMatcher = matcher;
	        var numberingSystem = GetOption(opts, 'numberingSystem', 'string', undefined, undefined);
	        if (numberingSystem !== undefined) {
	            if (!NUMBERING_SYSTEM_REGEX.test(numberingSystem)) {
	                throw new RangeError("Invalid numbering system " + numberingSystem);
	            }
	        }
	        opt.nu = numberingSystem;
	        var r = ResolveLocale(RelativeTimeFormat.availableLocales, requestedLocales, opt, RelativeTimeFormat.relevantExtensionKeys, RelativeTimeFormat.localeData, RelativeTimeFormat.getDefaultLocale);
	        var locale = r.locale, nu = r.nu;
	        setInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'locale', locale);
	        setInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'style', GetOption(opts, 'style', 'string', ['long', 'narrow', 'short'], 'long'));
	        setInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'numeric', GetOption(opts, 'numeric', 'string', ['always', 'auto'], 'always'));
	        setInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'fields', RelativeTimeFormat.localeData[locale]);
	        setInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'numberFormat', new Intl.NumberFormat(locales));
	        setInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'pluralRules', new Intl.PluralRules(locales));
	        setInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'numberingSystem', nu);
	    }
	    RelativeTimeFormat.prototype.format = function (value, unit) {
	        if (typeof this !== 'object') {
	            throw new TypeError('format was called on a non-object');
	        }
	        if (!getInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'initializedRelativeTimeFormat')) {
	            throw new TypeError('format was called on a invalid context');
	        }
	        return partitionRelativeTimePattern(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, Number(value), ToString(unit))
	            .map(function (el) { return el.value; })
	            .join('');
	    };
	    RelativeTimeFormat.prototype.formatToParts = function (value, unit) {
	        if (typeof this !== 'object') {
	            throw new TypeError('formatToParts was called on a non-object');
	        }
	        if (!getInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'initializedRelativeTimeFormat')) {
	            throw new TypeError('formatToParts was called on a invalid context');
	        }
	        return partitionRelativeTimePattern(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, Number(value), ToString(unit));
	    };
	    RelativeTimeFormat.prototype.resolvedOptions = function () {
	        if (typeof this !== 'object') {
	            throw new TypeError('resolvedOptions was called on a non-object');
	        }
	        if (!getInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'initializedRelativeTimeFormat')) {
	            throw new TypeError('resolvedOptions was called on a invalid context');
	        }
	        // test262/test/intl402/RelativeTimeFormat/prototype/resolvedOptions/type.js
	        return {
	            locale: getInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'locale'),
	            style: getInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'style'),
	            numeric: getInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'numeric'),
	            numberingSystem: getInternalSlot(RelativeTimeFormat.__INTERNAL_SLOT_MAP__, this, 'numberingSystem'),
	        };
	    };
	    RelativeTimeFormat.supportedLocalesOf = function (locales, options) {
	        return SupportedLocales(RelativeTimeFormat.availableLocales, Intl.getCanonicalLocales(locales), options);
	    };
	    RelativeTimeFormat.__addLocaleData = function () {
	        var data = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            data[_i] = arguments[_i];
	        }
	        var _loop_1 = function (datum) {
	            var availableLocales = datum.availableLocales;
	            availableLocales.forEach(function (locale) {
	                try {
	                    RelativeTimeFormat.localeData[locale] = unpackData(locale, datum);
	                }
	                catch (e) {
	                    if (isMissingLocaleDataError(e)) {
	                        // If we just don't have data for certain locale, that's ok
	                        return;
	                    }
	                    throw e;
	                }
	            });
	        };
	        for (var _a = 0, data_1 = data; _a < data_1.length; _a++) {
	            var datum = data_1[_a];
	            _loop_1(datum);
	        }
	        RelativeTimeFormat.availableLocales = Object.keys(RelativeTimeFormat.localeData);
	        if (!RelativeTimeFormat.__defaultLocale) {
	            RelativeTimeFormat.__defaultLocale =
	                RelativeTimeFormat.availableLocales[0];
	        }
	    };
	    RelativeTimeFormat.getDefaultLocale = function () {
	        return RelativeTimeFormat.__defaultLocale;
	    };
	    RelativeTimeFormat.localeData = {};
	    RelativeTimeFormat.availableLocales = [];
	    RelativeTimeFormat.__defaultLocale = 'en';
	    RelativeTimeFormat.relevantExtensionKeys = ['nu'];
	    RelativeTimeFormat.polyfilled = true;
	    RelativeTimeFormat.__INTERNAL_SLOT_MAP__ = new WeakMap();
	    return RelativeTimeFormat;
	}());
	try {
	    // IE11 does not have Symbol
	    if (typeof Symbol !== 'undefined') {
	        Object.defineProperty(RelativeTimeFormat.prototype, Symbol.toStringTag, {
	            value: 'Intl.RelativeTimeFormat',
	            writable: false,
	            enumerable: false,
	            configurable: true,
	        });
	    }
	    // https://github.com/tc39/test262/blob/master/test/intl402/RelativeTimeFormat/constructor/length.js
	    Object.defineProperty(RelativeTimeFormat.prototype.constructor, 'length', {
	        value: 0,
	        writable: false,
	        enumerable: false,
	        configurable: true,
	    });
	    // https://github.com/tc39/test262/blob/master/test/intl402/RelativeTimeFormat/constructor/supportedLocalesOf/length.js
	    Object.defineProperty(RelativeTimeFormat.supportedLocalesOf, 'length', {
	        value: 1,
	        writable: false,
	        enumerable: false,
	        configurable: true,
	    });
	}
	catch (e) {
	    // Meta fix so we're test262-compliant, not important
	}

	function shouldPolyfill() {
	    return typeof Intl === 'undefined' || !('RelativeTimeFormat' in Intl);
	}

	if (shouldPolyfill()) {
	    Object.defineProperty(Intl, 'RelativeTimeFormat', {
	        value: RelativeTimeFormat,
	        writable: true,
	        enumerable: false,
	        configurable: true,
	    });
	}

})));
//# sourceMappingURL=polyfill.umd.js.map
