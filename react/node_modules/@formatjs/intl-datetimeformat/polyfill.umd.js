(function (factory) {
	typeof define === 'function' && define.amd ? define(factory) :
	factory();
}((function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, basedir, module) {
		return module = {
		  path: basedir,
		  exports: {},
		  require: function (path, base) {
	      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
	    }
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	/* eslint complexity: [2, 18], max-statements: [2, 33] */
	var shams = function hasSymbols() {
		if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
		if (typeof Symbol.iterator === 'symbol') { return true; }

		var obj = {};
		var sym = Symbol('test');
		var symObj = Object(sym);
		if (typeof sym === 'string') { return false; }

		if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
		if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

		// temp disabled per https://github.com/ljharb/object.assign/issues/17
		// if (sym instanceof Symbol) { return false; }
		// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
		// if (!(symObj instanceof Symbol)) { return false; }

		// if (typeof Symbol.prototype.toString !== 'function') { return false; }
		// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

		var symVal = 42;
		obj[sym] = symVal;
		for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
		if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

		if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) { return false; }

		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

		if (typeof Object.getOwnPropertyDescriptor === 'function') {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
		}

		return true;
	};

	var origSymbol = commonjsGlobal.Symbol;


	var hasSymbols = function hasNativeSymbols() {
		if (typeof origSymbol !== 'function') { return false; }
		if (typeof Symbol !== 'function') { return false; }
		if (typeof origSymbol('foo') !== 'symbol') { return false; }
		if (typeof Symbol('bar') !== 'symbol') { return false; }

		return shams();
	};

	/* eslint no-invalid-this: 1 */

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var slice = Array.prototype.slice;
	var toStr = Object.prototype.toString;
	var funcType = '[object Function]';

	var implementation = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slice.call(arguments, 1);

	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                args.concat(slice.call(arguments))
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        } else {
	            return target.apply(
	                that,
	                args.concat(slice.call(arguments))
	            );
	        }
	    };

	    var boundLength = Math.max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs.push('$' + i);
	    }

	    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};

	var functionBind = Function.prototype.bind || implementation;

	/* globals
		Atomics,
		SharedArrayBuffer,
	*/

	var undefined$1;

	var $TypeError = TypeError;

	var $gOPD = Object.getOwnPropertyDescriptor;
	if ($gOPD) {
		try {
			$gOPD({}, '');
		} catch (e) {
			$gOPD = null; // this is IE 8, which has a broken gOPD
		}
	}

	var throwTypeError = function () { throw new $TypeError(); };
	var ThrowTypeError = $gOPD
		? (function () {
			try {
				// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
				arguments.callee; // IE 8 does not throw here
				return throwTypeError;
			} catch (calleeThrows) {
				try {
					// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
					return $gOPD(arguments, 'callee').get;
				} catch (gOPDthrows) {
					return throwTypeError;
				}
			}
		}())
		: throwTypeError;

	var hasSymbols$1 = hasSymbols();

	var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto
	var generatorFunction =  undefined$1;
	var asyncFunction =  undefined$1;
	var asyncGenFunction =  undefined$1;

	var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto(Uint8Array);

	var INTRINSICS = {
		'%Array%': Array,
		'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
		'%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer.prototype,
		'%ArrayIteratorPrototype%': hasSymbols$1 ? getProto([][Symbol.iterator]()) : undefined$1,
		'%ArrayPrototype%': Array.prototype,
		'%ArrayProto_entries%': Array.prototype.entries,
		'%ArrayProto_forEach%': Array.prototype.forEach,
		'%ArrayProto_keys%': Array.prototype.keys,
		'%ArrayProto_values%': Array.prototype.values,
		'%AsyncFromSyncIteratorPrototype%': undefined$1,
		'%AsyncFunction%': asyncFunction,
		'%AsyncFunctionPrototype%':  undefined$1,
		'%AsyncGenerator%':  undefined$1,
		'%AsyncGeneratorFunction%': asyncGenFunction,
		'%AsyncGeneratorPrototype%':  undefined$1,
		'%AsyncIteratorPrototype%':  undefined$1,
		'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
		'%Boolean%': Boolean,
		'%BooleanPrototype%': Boolean.prototype,
		'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
		'%DataViewPrototype%': typeof DataView === 'undefined' ? undefined$1 : DataView.prototype,
		'%Date%': Date,
		'%DatePrototype%': Date.prototype,
		'%decodeURI%': decodeURI,
		'%decodeURIComponent%': decodeURIComponent,
		'%encodeURI%': encodeURI,
		'%encodeURIComponent%': encodeURIComponent,
		'%Error%': Error,
		'%ErrorPrototype%': Error.prototype,
		'%eval%': eval, // eslint-disable-line no-eval
		'%EvalError%': EvalError,
		'%EvalErrorPrototype%': EvalError.prototype,
		'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
		'%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array.prototype,
		'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
		'%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array.prototype,
		'%Function%': Function,
		'%FunctionPrototype%': Function.prototype,
		'%Generator%':  undefined$1,
		'%GeneratorFunction%': generatorFunction,
		'%GeneratorPrototype%':  undefined$1,
		'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
		'%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array.prototype,
		'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
		'%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined$1 : Int8Array.prototype,
		'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
		'%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array.prototype,
		'%isFinite%': isFinite,
		'%isNaN%': isNaN,
		'%IteratorPrototype%': hasSymbols$1 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
		'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
		'%JSONParse%': typeof JSON === 'object' ? JSON.parse : undefined$1,
		'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
		'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
		'%MapPrototype%': typeof Map === 'undefined' ? undefined$1 : Map.prototype,
		'%Math%': Math,
		'%Number%': Number,
		'%NumberPrototype%': Number.prototype,
		'%Object%': Object,
		'%ObjectPrototype%': Object.prototype,
		'%ObjProto_toString%': Object.prototype.toString,
		'%ObjProto_valueOf%': Object.prototype.valueOf,
		'%parseFloat%': parseFloat,
		'%parseInt%': parseInt,
		'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
		'%PromisePrototype%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype,
		'%PromiseProto_then%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype.then,
		'%Promise_all%': typeof Promise === 'undefined' ? undefined$1 : Promise.all,
		'%Promise_reject%': typeof Promise === 'undefined' ? undefined$1 : Promise.reject,
		'%Promise_resolve%': typeof Promise === 'undefined' ? undefined$1 : Promise.resolve,
		'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
		'%RangeError%': RangeError,
		'%RangeErrorPrototype%': RangeError.prototype,
		'%ReferenceError%': ReferenceError,
		'%ReferenceErrorPrototype%': ReferenceError.prototype,
		'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
		'%RegExp%': RegExp,
		'%RegExpPrototype%': RegExp.prototype,
		'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
		'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
		'%SetPrototype%': typeof Set === 'undefined' ? undefined$1 : Set.prototype,
		'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
		'%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer.prototype,
		'%String%': String,
		'%StringIteratorPrototype%': hasSymbols$1 ? getProto(''[Symbol.iterator]()) : undefined$1,
		'%StringPrototype%': String.prototype,
		'%Symbol%': hasSymbols$1 ? Symbol : undefined$1,
		'%SymbolPrototype%': hasSymbols$1 ? Symbol.prototype : undefined$1,
		'%SyntaxError%': SyntaxError,
		'%SyntaxErrorPrototype%': SyntaxError.prototype,
		'%ThrowTypeError%': ThrowTypeError,
		'%TypedArray%': TypedArray,
		'%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined$1,
		'%TypeError%': $TypeError,
		'%TypeErrorPrototype%': $TypeError.prototype,
		'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
		'%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array.prototype,
		'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
		'%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray.prototype,
		'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
		'%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array.prototype,
		'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
		'%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array.prototype,
		'%URIError%': URIError,
		'%URIErrorPrototype%': URIError.prototype,
		'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
		'%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap.prototype,
		'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,
		'%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet.prototype
	};


	var $replace = functionBind.call(Function.call, String.prototype.replace);

	/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
	var stringToPath = function stringToPath(string) {
		var result = [];
		$replace(string, rePropName, function (match, number, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : (number || match);
		});
		return result;
	};
	/* end adaptation */

	var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
		if (!(name in INTRINSICS)) {
			throw new SyntaxError('intrinsic ' + name + ' does not exist!');
		}

		// istanbul ignore if // hopefully this is impossible to test :-)
		if (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return INTRINSICS[name];
	};

	var GetIntrinsic = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== 'string' || name.length === 0) {
			throw new TypeError('intrinsic name must be a non-empty string');
		}
		if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
			throw new TypeError('"allowMissing" argument must be a boolean');
		}

		var parts = stringToPath(name);

		var value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);
		for (var i = 1; i < parts.length; i += 1) {
			if (value != null) {
				if ($gOPD && (i + 1) >= parts.length) {
					var desc = $gOPD(value, parts[i]);
					if (!allowMissing && !(parts[i] in value)) {
						throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
					}
					value = desc ? (desc.get || desc.value) : value[parts[i]];
				} else {
					value = value[parts[i]];
				}
			}
		}
		return value;
	};

	var $String = GetIntrinsic('%String%');
	var $TypeError$1 = GetIntrinsic('%TypeError%');

	// https://www.ecma-international.org/ecma-262/6.0/#sec-tostring

	var ToString = function ToString(argument) {
		if (typeof argument === 'symbol') {
			throw new $TypeError$1('Cannot convert a Symbol value to a string');
		}
		return $String(argument);
	};

	/**
	 * https://tc39.es/ecma402/#sec-getoption
	 * @param opts
	 * @param prop
	 * @param type
	 * @param values
	 * @param fallback
	 */
	function GetOption(opts, prop, type, values, fallback) {
	    // const descriptor = Object.getOwnPropertyDescriptor(opts, prop);
	    var value = opts[prop];
	    if (value !== undefined) {
	        if (type !== 'boolean' && type !== 'string') {
	            throw new TypeError('invalid type');
	        }
	        if (type === 'boolean') {
	            value = Boolean(value);
	        }
	        if (type === 'string') {
	            value = ToString(value);
	        }
	        if (values !== undefined && !values.filter(function (val) { return val == value; }).length) {
	            throw new RangeError(value + " is not within " + values.join(', '));
	        }
	        return value;
	    }
	    return fallback;
	}

	/**
	 * Cannot do Math.log(x) / Math.log(10) bc if IEEE floating point issue
	 * @param x number
	 */
	/*
	  17 ECMAScript Standard Built-in Objects:
	    Every built-in Function object, including constructors, that is not
	    identified as an anonymous function has a name property whose value
	    is a String.

	    Unless otherwise specified, the name property of a built-in Function
	    object, if it exists, has the attributes { [[Writable]]: false,
	    [[Enumerable]]: false, [[Configurable]]: true }.
	*/
	function defineProperty(target, name, _a) {
	    var value = _a.value;
	    Object.defineProperty(target, name, {
	        configurable: true,
	        enumerable: false,
	        writable: true,
	        value: value,
	    });
	}
	var UNICODE_EXTENSION_SEQUENCE_REGEX = /-u(?:-[0-9a-z]{2,8})+/gi;
	function invariant(condition, message, Err) {
	    if (Err === void 0) { Err = Error; }
	    if (!condition) {
	        throw new Err(message);
	    }
	}

	/**
	 * https://tc39.es/ecma402/#sec-partitionpattern
	 * @param pattern
	 */
	function PartitionPattern(pattern) {
	    var result = [];
	    var beginIndex = pattern.indexOf('{');
	    var endIndex = 0;
	    var nextIndex = 0;
	    var length = pattern.length;
	    while (beginIndex < pattern.length && beginIndex > -1) {
	        endIndex = pattern.indexOf('}', beginIndex);
	        invariant(endIndex > beginIndex, "Invalid pattern " + pattern);
	        if (beginIndex > nextIndex) {
	            result.push({
	                type: 'literal',
	                value: pattern.substring(nextIndex, beginIndex),
	            });
	        }
	        result.push({
	            type: pattern.substring(beginIndex + 1, endIndex),
	            value: undefined,
	        });
	        nextIndex = endIndex + 1;
	        beginIndex = pattern.indexOf('{', nextIndex);
	    }
	    if (nextIndex < length) {
	        result.push({
	            type: 'literal',
	            value: pattern.substring(nextIndex, length),
	        });
	    }
	    return result;
	}

	/**
	 * https://tc39.es/ecma402/#sec-bestavailablelocale
	 * @param availableLocales
	 * @param locale
	 */
	function BestAvailableLocale(availableLocales, locale) {
	    var candidate = locale;
	    while (true) {
	        if (~availableLocales.indexOf(candidate)) {
	            return candidate;
	        }
	        var pos = candidate.lastIndexOf('-');
	        if (!~pos) {
	            return undefined;
	        }
	        if (pos >= 2 && candidate[pos - 2] === '-') {
	            pos -= 2;
	        }
	        candidate = candidate.slice(0, pos);
	    }
	}

	/**
	 * https://tc39.es/ecma402/#sec-lookupmatcher
	 * @param availableLocales
	 * @param requestedLocales
	 * @param getDefaultLocale
	 */
	function LookupMatcher(availableLocales, requestedLocales, getDefaultLocale) {
	    var result = { locale: '' };
	    for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
	        var locale = requestedLocales_1[_i];
	        var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
	        var availableLocale = BestAvailableLocale(availableLocales, noExtensionLocale);
	        if (availableLocale) {
	            result.locale = availableLocale;
	            if (locale !== noExtensionLocale) {
	                result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);
	            }
	            return result;
	        }
	    }
	    result.locale = getDefaultLocale();
	    return result;
	}

	/**
	 * https://tc39.es/ecma402/#sec-bestfitmatcher
	 * @param availableLocales
	 * @param requestedLocales
	 * @param getDefaultLocale
	 */
	function BestFitMatcher(availableLocales, requestedLocales, getDefaultLocale) {
	    var result = { locale: '' };
	    for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
	        var locale = requestedLocales_1[_i];
	        var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
	        var availableLocale = BestAvailableLocale(availableLocales, noExtensionLocale);
	        if (availableLocale) {
	            result.locale = availableLocale;
	            if (locale !== noExtensionLocale) {
	                result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);
	            }
	            return result;
	        }
	    }
	    result.locale = getDefaultLocale();
	    return result;
	}

	/**
	 * https://tc39.es/ecma402/#sec-unicodeextensionvalue
	 * @param extension
	 * @param key
	 */
	function UnicodeExtensionValue(extension, key) {
	    invariant(key.length === 2, 'key must have 2 elements');
	    var size = extension.length;
	    var searchValue = "-" + key + "-";
	    var pos = extension.indexOf(searchValue);
	    if (pos !== -1) {
	        var start = pos + 4;
	        var end = start;
	        var k = start;
	        var done = false;
	        while (!done) {
	            var e = extension.indexOf('-', k);
	            var len = void 0;
	            if (e === -1) {
	                len = size - k;
	            }
	            else {
	                len = e - k;
	            }
	            if (len === 2) {
	                done = true;
	            }
	            else if (e === -1) {
	                end = size;
	                done = true;
	            }
	            else {
	                end = e;
	                k = e + 1;
	            }
	        }
	        return extension.slice(start, end);
	    }
	    searchValue = "-" + key;
	    pos = extension.indexOf(searchValue);
	    if (pos !== -1 && pos + 3 === size) {
	        return '';
	    }
	    return undefined;
	}

	/**
	 * https://tc39.es/ecma402/#sec-resolvelocale
	 */
	function ResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData, getDefaultLocale) {
	    var matcher = options.localeMatcher;
	    var r;
	    if (matcher === 'lookup') {
	        r = LookupMatcher(availableLocales, requestedLocales, getDefaultLocale);
	    }
	    else {
	        r = BestFitMatcher(availableLocales, requestedLocales, getDefaultLocale);
	    }
	    var foundLocale = r.locale;
	    var result = { locale: '', dataLocale: foundLocale };
	    var supportedExtension = '-u';
	    for (var _i = 0, relevantExtensionKeys_1 = relevantExtensionKeys; _i < relevantExtensionKeys_1.length; _i++) {
	        var key = relevantExtensionKeys_1[_i];
	        var foundLocaleData = localeData[foundLocale];
	        invariant(typeof foundLocaleData === 'object' && foundLocaleData !== null, "locale data " + key + " must be an object");
	        var keyLocaleData = foundLocaleData[key];
	        invariant(Array.isArray(keyLocaleData), "keyLocaleData for " + key + " must be an array");
	        var value = keyLocaleData[0];
	        invariant(typeof value === 'string' || value === null, "value must be string or null but got " + typeof value + " in key " + key);
	        var supportedExtensionAddition = '';
	        if (r.extension) {
	            var requestedValue = UnicodeExtensionValue(r.extension, key);
	            if (requestedValue !== undefined) {
	                if (requestedValue !== '') {
	                    if (~keyLocaleData.indexOf(requestedValue)) {
	                        value = requestedValue;
	                        supportedExtensionAddition = "-" + key + "-" + value;
	                    }
	                }
	                else if (~requestedValue.indexOf('true')) {
	                    value = 'true';
	                    supportedExtensionAddition = "-" + key;
	                }
	            }
	        }
	        if (key in options) {
	            var optionsValue = options[key];
	            invariant(typeof optionsValue === 'string' ||
	                typeof optionsValue === 'undefined' ||
	                optionsValue === null, 'optionsValue must be String, Undefined or Null');
	            if (~keyLocaleData.indexOf(optionsValue)) {
	                if (optionsValue !== value) {
	                    value = optionsValue;
	                    supportedExtensionAddition = '';
	                }
	            }
	        }
	        result[key] = value;
	        supportedExtension += supportedExtensionAddition;
	    }
	    if (supportedExtension.length > 2) {
	        var privateIndex = foundLocale.indexOf('-x-');
	        if (privateIndex === -1) {
	            foundLocale = foundLocale + supportedExtension;
	        }
	        else {
	            var preExtension = foundLocale.slice(0, privateIndex);
	            var postExtension = foundLocale.slice(privateIndex, foundLocale.length);
	            foundLocale = preExtension + supportedExtension + postExtension;
	        }
	        foundLocale = Intl.getCanonicalLocales(foundLocale)[0];
	    }
	    result.locale = foundLocale;
	    return result;
	}

	var $TypeError$2 = GetIntrinsic('%TypeError%');

	// http://www.ecma-international.org/ecma-262/5.1/#sec-9.10

	var CheckObjectCoercible = function CheckObjectCoercible(value, optMessage) {
		if (value == null) {
			throw new $TypeError$2(optMessage || ('Cannot call method on ' + value));
		}
		return value;
	};

	var RequireObjectCoercible = CheckObjectCoercible;

	var $Object = GetIntrinsic('%Object%');



	// https://www.ecma-international.org/ecma-262/6.0/#sec-toobject

	var ToObject = function ToObject(value) {
		RequireObjectCoercible(value);
		return $Object(value);
	};

	/**
	 * https://tc39.es/ecma402/#sec-lookupsupportedlocales
	 * @param availableLocales
	 * @param requestedLocales
	 */
	function LookupSupportedLocales(availableLocales, requestedLocales) {
	    var subset = [];
	    for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
	        var locale = requestedLocales_1[_i];
	        var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
	        var availableLocale = BestAvailableLocale(availableLocales, noExtensionLocale);
	        if (availableLocale) {
	            subset.push(availableLocale);
	        }
	    }
	    return subset;
	}

	/**
	 * https://tc39.es/ecma402/#sec-supportedlocales
	 * @param availableLocales
	 * @param requestedLocales
	 * @param options
	 */
	function SupportedLocales(availableLocales, requestedLocales, options) {
	    var matcher = 'best fit';
	    if (options !== undefined) {
	        options = ToObject(options);
	        matcher = GetOption(options, 'localeMatcher', 'string', ['lookup', 'best fit'], 'best fit');
	    }
	    if (matcher === 'best fit') {
	        return LookupSupportedLocales(availableLocales, requestedLocales);
	    }
	    return LookupSupportedLocales(availableLocales, requestedLocales);
	}

	var __extends = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (undefined && undefined.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	function getLocaleHierarchy(locale) {
	    var results = [locale];
	    var localeParts = locale.split('-');
	    for (var i = localeParts.length; i > 1; i--) {
	        results.push(localeParts.slice(0, i - 1).join('-'));
	    }
	    return results;
	}
	var MissingLocaleDataError = /** @class */ (function (_super) {
	    __extends(MissingLocaleDataError, _super);
	    function MissingLocaleDataError() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.type = 'MISSING_LOCALE_DATA';
	        return _this;
	    }
	    return MissingLocaleDataError;
	}(Error));
	function unpackData(locale, localeData, 
	/** By default shallow merge the dictionaries. */
	reducer) {
	    if (reducer === void 0) { reducer = function (all, d) { return (__assign(__assign({}, all), d)); }; }
	    var localeHierarchy = getLocaleHierarchy(locale);
	    var dataToMerge = localeHierarchy
	        .map(function (l) { return localeData.data[l]; })
	        .filter(Boolean);
	    if (!dataToMerge.length) {
	        throw new MissingLocaleDataError("Missing locale data for \"" + locale + "\", lookup hierarchy: " + localeHierarchy.join(', '));
	    }
	    dataToMerge.reverse();
	    return dataToMerge.reduce(reducer, {});
	}

	// Type-only circular import
	// eslint-disable-next-line import/no-cycle
	var internalSlotMap = new WeakMap();
	function getInternalSlots(x) {
	    var internalSlots = internalSlotMap.get(x);
	    if (!internalSlots) {
	        internalSlots = Object.create(null);
	        internalSlotMap.set(x, internalSlots);
	    }
	    return internalSlots;
	}

	// @generated
	// prettier-ignore
	var links = { "Africa/Asmera": "Africa/Nairobi", "Africa/Timbuktu": "Africa/Abidjan", "America/Argentina/ComodRivadavia": "America/Argentina/Catamarca", "America/Atka": "America/Adak", "America/Buenos_Aires": "America/Argentina/Buenos_Aires", "America/Catamarca": "America/Argentina/Catamarca", "America/Coral_Harbour": "America/Atikokan", "America/Cordoba": "America/Argentina/Cordoba", "America/Ensenada": "America/Tijuana", "America/Fort_Wayne": "America/Indiana/Indianapolis", "America/Godthab": "America/Nuuk", "America/Indianapolis": "America/Indiana/Indianapolis", "America/Jujuy": "America/Argentina/Jujuy", "America/Knox_IN": "America/Indiana/Knox", "America/Louisville": "America/Kentucky/Louisville", "America/Mendoza": "America/Argentina/Mendoza", "America/Montreal": "America/Toronto", "America/Porto_Acre": "America/Rio_Branco", "America/Rosario": "America/Argentina/Cordoba", "America/Santa_Isabel": "America/Tijuana", "America/Shiprock": "America/Denver", "America/Virgin": "America/Port_of_Spain", "Antarctica/South_Pole": "Pacific/Auckland", "Asia/Ashkhabad": "Asia/Ashgabat", "Asia/Calcutta": "Asia/Kolkata", "Asia/Chongqing": "Asia/Shanghai", "Asia/Chungking": "Asia/Shanghai", "Asia/Dacca": "Asia/Dhaka", "Asia/Harbin": "Asia/Shanghai", "Asia/Kashgar": "Asia/Urumqi", "Asia/Katmandu": "Asia/Kathmandu", "Asia/Macao": "Asia/Macau", "Asia/Rangoon": "Asia/Yangon", "Asia/Saigon": "Asia/Ho_Chi_Minh", "Asia/Tel_Aviv": "Asia/Jerusalem", "Asia/Thimbu": "Asia/Thimphu", "Asia/Ujung_Pandang": "Asia/Makassar", "Asia/Ulan_Bator": "Asia/Ulaanbaatar", "Atlantic/Faeroe": "Atlantic/Faroe", "Atlantic/Jan_Mayen": "Europe/Oslo", "Australia/ACT": "Australia/Sydney", "Australia/Canberra": "Australia/Sydney", "Australia/LHI": "Australia/Lord_Howe", "Australia/NSW": "Australia/Sydney", "Australia/North": "Australia/Darwin", "Australia/Queensland": "Australia/Brisbane", "Australia/South": "Australia/Adelaide", "Australia/Tasmania": "Australia/Hobart", "Australia/Victoria": "Australia/Melbourne", "Australia/West": "Australia/Perth", "Australia/Yancowinna": "Australia/Broken_Hill", "Brazil/Acre": "America/Rio_Branco", "Brazil/DeNoronha": "America/Noronha", "Brazil/East": "America/Sao_Paulo", "Brazil/West": "America/Manaus", "Canada/Atlantic": "America/Halifax", "Canada/Central": "America/Winnipeg", "Canada/Eastern": "America/Toronto", "Canada/Mountain": "America/Edmonton", "Canada/Newfoundland": "America/St_Johns", "Canada/Pacific": "America/Vancouver", "Canada/Saskatchewan": "America/Regina", "Canada/Yukon": "America/Whitehorse", "Chile/Continental": "America/Santiago", "Chile/EasterIsland": "Pacific/Easter", "Cuba": "America/Havana", "Egypt": "Africa/Cairo", "Eire": "Europe/Dublin", "Etc/UCT": "Etc/UTC", "Europe/Belfast": "Europe/London", "Europe/Tiraspol": "Europe/Chisinau", "GB": "Europe/London", "GB-Eire": "Europe/London", "GMT+0": "Etc/GMT", "GMT-0": "Etc/GMT", "GMT0": "Etc/GMT", "Greenwich": "Etc/GMT", "Hongkong": "Asia/Hong_Kong", "Iceland": "Atlantic/Reykjavik", "Iran": "Asia/Tehran", "Israel": "Asia/Jerusalem", "Jamaica": "America/Jamaica", "Japan": "Asia/Tokyo", "Kwajalein": "Pacific/Kwajalein", "Libya": "Africa/Tripoli", "Mexico/BajaNorte": "America/Tijuana", "Mexico/BajaSur": "America/Mazatlan", "Mexico/General": "America/Mexico_City", "NZ": "Pacific/Auckland", "NZ-CHAT": "Pacific/Chatham", "Navajo": "America/Denver", "PRC": "Asia/Shanghai", "Pacific/Johnston": "Pacific/Honolulu", "Pacific/Ponape": "Pacific/Pohnpei", "Pacific/Samoa": "Pacific/Pago_Pago", "Pacific/Truk": "Pacific/Chuuk", "Pacific/Yap": "Pacific/Chuuk", "Poland": "Europe/Warsaw", "Portugal": "Europe/Lisbon", "ROC": "Asia/Taipei", "ROK": "Asia/Seoul", "Singapore": "Asia/Singapore", "Turkey": "Europe/Istanbul", "UCT": "Etc/UTC", "US/Alaska": "America/Anchorage", "US/Aleutian": "America/Adak", "US/Arizona": "America/Phoenix", "US/Central": "America/Chicago", "US/East-Indiana": "America/Indiana/Indianapolis", "US/Eastern": "America/New_York", "US/Hawaii": "Pacific/Honolulu", "US/Indiana-Starke": "America/Indiana/Knox", "US/Michigan": "America/Detroit", "US/Mountain": "America/Denver", "US/Pacific": "America/Los_Angeles", "US/Samoa": "Pacific/Pago_Pago", "UTC": "Etc/UTC", "Universal": "Etc/UTC", "W-SU": "Europe/Moscow", "Zulu": "Etc/UTC" };

	var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
	    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	    for (var r = Array(s), k = 0, i = 0; i < il; i++)
	        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
	            r[k] = a[j];
	    return r;
	};
	function unpack(data) {
	    var abbrvs = data.abbrvs.split('|');
	    var offsets = data.offsets.split('|').map(function (n) { return parseInt(n, 36); });
	    var packedZones = data.zones;
	    var zones = {};
	    for (var _i = 0, packedZones_1 = packedZones; _i < packedZones_1.length; _i++) {
	        var d = packedZones_1[_i];
	        var _a = d.split('|'), zone = _a[0], zoneData = _a.slice(1);
	        zones[zone] = zoneData
	            .map(function (z) { return z.split(','); })
	            .map(function (_a) {
	            var ts = _a[0], abbrvIndex = _a[1], offsetIndex = _a[2], dst = _a[3];
	            return [
	                ts === '' ? -Infinity : parseInt(ts, 36),
	                abbrvs[+abbrvIndex],
	                offsets[+offsetIndex],
	                dst === '1',
	            ];
	        });
	    }
	    return zones;
	}

	/**
	 * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
	 * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js
	 * with some tweaks
	 */
	var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
	// trim patterns after transformations
	var expPatternTrimmer = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
	function matchSkeletonPattern(match, result) {
	    if (result === void 0) { result = {
	        pattern: '',
	        pattern12: '',
	        skeleton: '',
	        rawPattern: '',
	    }; }
	    var len = match.length;
	    switch (match[0]) {
	        // Era
	        case 'G':
	            result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
	            return '{era}';
	        // Year
	        case 'y':
	        case 'Y':
	        case 'u':
	        case 'U':
	        case 'r':
	            result.year = len === 2 ? '2-digit' : 'numeric';
	            return '{year}';
	        // Quarter
	        case 'q':
	        case 'Q':
	            throw new RangeError('`w/Q` (quarter) patterns are not supported');
	        // Month
	        case 'M':
	        case 'L':
	            result.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1];
	            return '{month}';
	        // Week
	        case 'w':
	        case 'W':
	            throw new RangeError('`w/W` (week of year) patterns are not supported');
	        case 'd':
	            result.day = ['numeric', '2-digit'][len - 1];
	            return '{day}';
	        case 'D':
	        case 'F':
	        case 'g':
	            result.day = 'numeric';
	            return '{day}';
	        // Weekday
	        case 'E':
	            result.weekday = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
	            return '{weekday}';
	        case 'e':
	            result.weekday = [
	                'numeric',
	                '2-digit',
	                'short',
	                'long',
	                'narrow',
	                'short',
	            ][len - 1];
	            return '{weekday}';
	        case 'c':
	            result.weekday = [
	                'numeric',
	                undefined,
	                'short',
	                'long',
	                'narrow',
	                'short',
	            ][len - 1];
	            return '{weekday}';
	        // Period
	        case 'a': // AM, PM
	        case 'b': // am, pm, noon, midnight
	        case 'B': // flexible day periods
	            result.hour12 = true;
	            return '{ampm}';
	        // Hour
	        case 'h':
	            result.hour = ['numeric', '2-digit'][len - 1];
	            return '{hour}';
	        case 'H':
	            result.hour = ['numeric', '2-digit'][len - 1];
	            return '{hour}';
	        case 'K':
	            result.hour = ['numeric', '2-digit'][len - 1];
	            return '{hour}';
	        case 'k':
	            result.hour = ['numeric', '2-digit'][len - 1];
	            return '{hour}';
	        case 'j':
	        case 'J':
	        case 'C':
	            throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');
	        // Minute
	        case 'm':
	            result.minute = ['numeric', '2-digit'][len - 1];
	            return '{minute}';
	        // Second
	        case 's':
	            result.second = ['numeric', '2-digit'][len - 1];
	            return '{second}';
	        case 'S':
	        case 'A':
	            result.second = 'numeric';
	            return '{second}';
	        // Zone
	        case 'z': // 1..3, 4: specific non-location format
	        case 'Z': // 1..3, 4, 5: The ISO8601 varios formats
	        case 'O': // 1, 4: miliseconds in day short, long
	        case 'v': // 1, 4: generic non-location format
	        case 'V': // 1, 2, 3, 4: time zone ID or city
	        case 'X': // 1, 2, 3, 4: The ISO8601 varios formats
	        case 'x': // 1, 2, 3, 4: The ISO8601 varios formats
	            result.timeZoneName = len < 4 ? 'short' : 'long';
	            return '{timeZoneName}';
	    }
	    return '';
	}
	/**
	 * Parse Date time skeleton into Intl.DateTimeFormatOptions
	 * Ref: https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
	 * @public
	 * @param skeleton skeleton string
	 */
	function parseDateTimeSkeleton(skeleton, pattern) {
	    if (pattern === void 0) { pattern = skeleton; }
	    var result = {
	        pattern: '',
	        pattern12: '',
	        skeleton: skeleton,
	        rawPattern: pattern,
	    };
	    var literals = [];
	    // Use skeleton to populate result, but use mapped pattern to populate pattern
	    result.pattern12 = pattern
	        // Double apostrophe
	        .replace(/'{2}/g, '{apostrophe}')
	        // Apostrophe-escaped
	        .replace(/'(.*?)'/g, function (_, literal) {
	        literals.push(literal);
	        return "$$" + (literals.length - 1) + "$$";
	    })
	        .replace(DATE_TIME_REGEX, matchSkeletonPattern);
	    skeleton.replace(DATE_TIME_REGEX, function (m) { return matchSkeletonPattern(m, result); });
	    //Restore literals
	    if (literals.length) {
	        result.pattern12 = result.pattern12
	            .replace(/\$\$(\d+)\$\$/g, function (_, i) {
	            return literals[+i];
	        })
	            .replace(/\{apostrophe\}/g, "'");
	    }
	    // Handle apostrophe-escaped things
	    result.pattern = result.pattern12
	        .replace(/([\s\uFEFF\xA0])\{ampm\}([\s\uFEFF\xA0])/, '$1')
	        .replace('{ampm}', '')
	        .replace(expPatternTrimmer, '');
	    return result;
	}

	var $isNaN = Number.isNaN || function (a) { return a !== a; };

	var _isFinite = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };

	var $apply = GetIntrinsic('%Function.prototype.apply%');
	var $call = GetIntrinsic('%Function.prototype.call%');
	var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || functionBind.call($call, $apply);

	var callBind = function callBind() {
		return $reflectApply(functionBind, $call, arguments);
	};

	var apply = function applyBind() {
		return $reflectApply(functionBind, $apply, arguments);
	};
	callBind.apply = apply;

	var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

	var callBound = function callBoundIntrinsic(name, allowMissing) {
		var intrinsic = GetIntrinsic(name, !!allowMissing);
		if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.')) {
			return callBind(intrinsic);
		}
		return intrinsic;
	};

	var $test = GetIntrinsic('RegExp.prototype.test');



	var regexTester = function regexTester(regex) {
		return callBind($test, regex);
	};

	var isPrimitive = function isPrimitive(value) {
		return value === null || (typeof value !== 'function' && typeof value !== 'object');
	};

	var isPrimitive$1 = function isPrimitive(value) {
		return value === null || (typeof value !== 'function' && typeof value !== 'object');
	};

	var fnToStr = Function.prototype.toString;
	var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
	var badArrayLike;
	var isCallableMarker;
	if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
		try {
			badArrayLike = Object.defineProperty({}, 'length', {
				get: function () {
					throw isCallableMarker;
				}
			});
			isCallableMarker = {};
		} catch (_) {
			reflectApply = null;
		}
	} else {
		reflectApply = null;
	}

	var constructorRegex = /^\s*class\b/;
	var isES6ClassFn = function isES6ClassFunction(value) {
		try {
			var fnStr = fnToStr.call(value);
			return constructorRegex.test(fnStr);
		} catch (e) {
			return false; // not a function
		}
	};

	var tryFunctionObject = function tryFunctionToStr(value) {
		try {
			if (isES6ClassFn(value)) { return false; }
			fnToStr.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr$1 = Object.prototype.toString;
	var fnClass = '[object Function]';
	var genClass = '[object GeneratorFunction]';
	var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	var isCallable = reflectApply
		? function isCallable(value) {
			if (!value) { return false; }
			if (typeof value !== 'function' && typeof value !== 'object') { return false; }
			if (typeof value === 'function' && !value.prototype) { return true; }
			try {
				reflectApply(value, null, badArrayLike);
			} catch (e) {
				if (e !== isCallableMarker) { return false; }
			}
			return !isES6ClassFn(value);
		}
		: function isCallable(value) {
			if (!value) { return false; }
			if (typeof value !== 'function' && typeof value !== 'object') { return false; }
			if (typeof value === 'function' && !value.prototype) { return true; }
			if (hasToStringTag) { return tryFunctionObject(value); }
			if (isES6ClassFn(value)) { return false; }
			var strClass = toStr$1.call(value);
			return strClass === fnClass || strClass === genClass;
		};

	var getDay = Date.prototype.getDay;
	var tryDateObject = function tryDateGetDayCall(value) {
		try {
			getDay.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};

	var toStr$2 = Object.prototype.toString;
	var dateClass = '[object Date]';
	var hasToStringTag$1 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

	var isDateObject = function isDateObject(value) {
		if (typeof value !== 'object' || value === null) {
			return false;
		}
		return hasToStringTag$1 ? tryDateObject(value) : toStr$2.call(value) === dateClass;
	};

	var isSymbol = createCommonjsModule(function (module) {

	var toStr = Object.prototype.toString;
	var hasSymbols$1 = hasSymbols();

	if (hasSymbols$1) {
		var symToStr = Symbol.prototype.toString;
		var symStringRegex = /^Symbol\(.*\)$/;
		var isSymbolObject = function isRealSymbolObject(value) {
			if (typeof value.valueOf() !== 'symbol') {
				return false;
			}
			return symStringRegex.test(symToStr.call(value));
		};

		module.exports = function isSymbol(value) {
			if (typeof value === 'symbol') {
				return true;
			}
			if (toStr.call(value) !== '[object Symbol]') {
				return false;
			}
			try {
				return isSymbolObject(value);
			} catch (e) {
				return false;
			}
		};
	} else {

		module.exports = function isSymbol(value) {
			// this environment does not support Symbols.
			return false ;
		};
	}
	});

	var hasSymbols$2 = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';






	var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
		if (typeof O === 'undefined' || O === null) {
			throw new TypeError('Cannot call method on ' + O);
		}
		if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
			throw new TypeError('hint must be "string" or "number"');
		}
		var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
		var method, result, i;
		for (i = 0; i < methodNames.length; ++i) {
			method = O[methodNames[i]];
			if (isCallable(method)) {
				result = method.call(O);
				if (isPrimitive$1(result)) {
					return result;
				}
			}
		}
		throw new TypeError('No default value');
	};

	var GetMethod = function GetMethod(O, P) {
		var func = O[P];
		if (func !== null && typeof func !== 'undefined') {
			if (!isCallable(func)) {
				throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
			}
			return func;
		}
		return void 0;
	};

	// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
	var es2015 = function ToPrimitive(input) {
		if (isPrimitive$1(input)) {
			return input;
		}
		var hint = 'default';
		if (arguments.length > 1) {
			if (arguments[1] === String) {
				hint = 'string';
			} else if (arguments[1] === Number) {
				hint = 'number';
			}
		}

		var exoticToPrim;
		if (hasSymbols$2) {
			if (Symbol.toPrimitive) {
				exoticToPrim = GetMethod(input, Symbol.toPrimitive);
			} else if (isSymbol(input)) {
				exoticToPrim = Symbol.prototype.valueOf;
			}
		}
		if (typeof exoticToPrim !== 'undefined') {
			var result = exoticToPrim.call(input, hint);
			if (isPrimitive$1(result)) {
				return result;
			}
			throw new TypeError('unable to convert exotic object to primitive');
		}
		if (hint === 'default' && (isDateObject(input) || isSymbol(input))) {
			hint = 'string';
		}
		return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
	};

	// https://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive

	var ToPrimitive = function ToPrimitive(input) {
		if (arguments.length > 1) {
			return es2015(input, arguments[1]);
		}
		return es2015(input);
	};

	var $TypeError$3 = GetIntrinsic('%TypeError%');
	var $Number = GetIntrinsic('%Number%');
	var $RegExp = GetIntrinsic('%RegExp%');
	var $parseInteger = GetIntrinsic('%parseInt%');





	var $strSlice = callBound('String.prototype.slice');
	var isBinary = regexTester(/^0b[01]+$/i);
	var isOctal = regexTester(/^0o[0-7]+$/i);
	var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
	var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
	var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
	var hasNonWS = regexTester(nonWSregex);

	// whitespace from: https://es5.github.io/#x15.5.4.20
	// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
	var ws = [
		'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
		'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
		'\u2029\uFEFF'
	].join('');
	var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
	var $replace$1 = callBound('String.prototype.replace');
	var $trim = function (value) {
		return $replace$1(value, trimRegex, '');
	};



	// https://www.ecma-international.org/ecma-262/6.0/#sec-tonumber

	var ToNumber = function ToNumber(argument) {
		var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
		if (typeof value === 'symbol') {
			throw new $TypeError$3('Cannot convert a Symbol value to a number');
		}
		if (typeof value === 'string') {
			if (isBinary(value)) {
				return ToNumber($parseInteger($strSlice(value, 2), 2));
			} else if (isOctal(value)) {
				return ToNumber($parseInteger($strSlice(value, 2), 8));
			} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
				return NaN;
			} else {
				var trimmed = $trim(value);
				if (trimmed !== value) {
					return ToNumber(trimmed);
				}
			}
		}
		return $Number(value);
	};

	var $Date = GetIntrinsic('%Date%');
	var $Number$1 = GetIntrinsic('%Number%');
	var $abs = GetIntrinsic('%Math.abs%');





	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.14

	var TimeClip = function TimeClip(time) {
		if (!_isFinite(time) || $abs(time) > 8.64e15) {
			return NaN;
		}
		return $Number$1(new $Date(ToNumber(time)));
	};

	var $floor = Math.floor;

	var mod = function mod(number, modulo) {
		var remain = number % modulo;
		return $floor(remain >= 0 ? remain : remain + modulo);
	};

	var HoursPerDay = 24;
	var MinutesPerHour = 60;
	var SecondsPerMinute = 60;
	var msPerSecond = 1e3;
	var msPerMinute = msPerSecond * SecondsPerMinute;
	var msPerHour = msPerMinute * MinutesPerHour;
	var msPerDay = 86400000;

	var timeConstants = {
		HoursPerDay: HoursPerDay,
		MinutesPerHour: MinutesPerHour,
		SecondsPerMinute: SecondsPerMinute,
		msPerSecond: msPerSecond,
		msPerMinute: msPerMinute,
		msPerHour: msPerHour,
		msPerDay: msPerDay
	};

	var $floor$1 = GetIntrinsic('%Math.floor%');

	var msPerDay$1 = timeConstants.msPerDay;

	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.2

	var Day = function Day(t) {
		return $floor$1(t / msPerDay$1);
	};

	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.6

	var WeekDay = function WeekDay(t) {
		return mod(Day(t) + 4, 7);
	};

	var $floor$2 = GetIntrinsic('%Math.floor%');

	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3

	var DayFromYear = function DayFromYear(y) {
		return (365 * (y - 1970)) + $floor$2((y - 1969) / 4) - $floor$2((y - 1901) / 100) + $floor$2((y - 1601) / 400);
	};

	var $Date$1 = GetIntrinsic('%Date%');



	var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3

	var YearFromTime = function YearFromTime(t) {
		// largest y such that this.TimeFromYear(y) <= t
		return $getUTCFullYear(new $Date$1(t));
	};

	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.4

	var DayWithinYear = function DayWithinYear(t) {
		return Day(t) - DayFromYear(YearFromTime(t));
	};

	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3

	var DaysInYear = function DaysInYear(y) {
		if (mod(y, 4) !== 0) {
			return 365;
		}
		if (mod(y, 100) !== 0) {
			return 366;
		}
		if (mod(y, 400) !== 0) {
			return 365;
		}
		return 366;
	};

	var $EvalError = GetIntrinsic('%EvalError%');




	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3

	var InLeapYear = function InLeapYear(t) {
		var days = DaysInYear(YearFromTime(t));
		if (days === 365) {
			return 0;
		}
		if (days === 366) {
			return 1;
		}
		throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
	};

	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.4

	var MonthFromTime = function MonthFromTime(t) {
		var day = DayWithinYear(t);
		if (0 <= day && day < 31) {
			return 0;
		}
		var leap = InLeapYear(t);
		if (31 <= day && day < (59 + leap)) {
			return 1;
		}
		if ((59 + leap) <= day && day < (90 + leap)) {
			return 2;
		}
		if ((90 + leap) <= day && day < (120 + leap)) {
			return 3;
		}
		if ((120 + leap) <= day && day < (151 + leap)) {
			return 4;
		}
		if ((151 + leap) <= day && day < (181 + leap)) {
			return 5;
		}
		if ((181 + leap) <= day && day < (212 + leap)) {
			return 6;
		}
		if ((212 + leap) <= day && day < (243 + leap)) {
			return 7;
		}
		if ((243 + leap) <= day && day < (273 + leap)) {
			return 8;
		}
		if ((273 + leap) <= day && day < (304 + leap)) {
			return 9;
		}
		if ((304 + leap) <= day && day < (334 + leap)) {
			return 10;
		}
		if ((334 + leap) <= day && day < (365 + leap)) {
			return 11;
		}
	};

	var $EvalError$1 = GetIntrinsic('%EvalError%');





	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.5

	var DateFromTime = function DateFromTime(t) {
		var m = MonthFromTime(t);
		var d = DayWithinYear(t);
		if (m === 0) {
			return d + 1;
		}
		if (m === 1) {
			return d - 30;
		}
		var leap = InLeapYear(t);
		if (m === 2) {
			return d - 58 - leap;
		}
		if (m === 3) {
			return d - 89 - leap;
		}
		if (m === 4) {
			return d - 119 - leap;
		}
		if (m === 5) {
			return d - 150 - leap;
		}
		if (m === 6) {
			return d - 180 - leap;
		}
		if (m === 7) {
			return d - 211 - leap;
		}
		if (m === 8) {
			return d - 242 - leap;
		}
		if (m === 9) {
			return d - 272 - leap;
		}
		if (m === 10) {
			return d - 303 - leap;
		}
		if (m === 11) {
			return d - 333 - leap;
		}
		throw new $EvalError$1('Assertion failed: MonthFromTime returned an impossible value: ' + m);
	};

	var $floor$3 = GetIntrinsic('%Math.floor%');



	var msPerHour$1 = timeConstants.msPerHour;
	var HoursPerDay$1 = timeConstants.HoursPerDay;

	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.10

	var HourFromTime = function HourFromTime(t) {
		return mod($floor$3(t / msPerHour$1), HoursPerDay$1);
	};

	var $floor$4 = GetIntrinsic('%Math.floor%');



	var msPerMinute$1 = timeConstants.msPerMinute;
	var MinutesPerHour$1 = timeConstants.MinutesPerHour;

	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.10

	var MinFromTime = function MinFromTime(t) {
		return mod($floor$4(t / msPerMinute$1), MinutesPerHour$1);
	};

	var $floor$5 = GetIntrinsic('%Math.floor%');



	var msPerSecond$1 = timeConstants.msPerSecond;
	var SecondsPerMinute$1 = timeConstants.SecondsPerMinute;

	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.10

	var SecFromTime = function SecFromTime(t) {
		return mod($floor$5(t / msPerSecond$1), SecondsPerMinute$1);
	};

	var __assign$1 = (undefined && undefined.__assign) || function () {
	    __assign$1 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1.apply(this, arguments);
	};
	var __rest = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var UPPERCASED_LINKS = Object.keys(links).reduce(function (all, l) {
	    all[l.toUpperCase()] = links[l];
	    return all;
	}, {});
	var DATE_TIME_PROPS = [
	    'weekday',
	    'era',
	    'year',
	    'month',
	    'day',
	    'hour',
	    'minute',
	    'second',
	    'timeZoneName',
	];
	var RESOLVED_OPTIONS_KEYS = [
	    'locale',
	    'calendar',
	    'numberingSystem',
	    'dateStyle',
	    'timeStyle',
	    'timeZone',
	    'hourCycle',
	    'weekday',
	    'era',
	    'year',
	    'month',
	    'day',
	    'hour',
	    'minute',
	    'second',
	    'timeZoneName',
	];
	var TYPE_REGEX = /^[a-z0-9]{3,8}$/i;
	/**
	 * https://tc39.es/ecma402/#sec-isvalidtimezonename
	 * @param tz
	 */
	function isValidTimeZoneName(tz) {
	    var uppercasedTz = tz.toUpperCase();
	    var zoneNames = new Set(Object.keys(DateTimeFormat.tzData).map(function (z) { return z.toUpperCase(); }));
	    return zoneNames.has(uppercasedTz) || uppercasedTz in UPPERCASED_LINKS;
	}
	/**
	 * https://tc39.es/ecma402/#sec-canonicalizetimezonename
	 * @param tz
	 */
	function canonicalizeTimeZoneName(tz) {
	    var uppercasedTz = tz.toUpperCase();
	    var uppercasedZones = Object.keys(DateTimeFormat.tzData).reduce(function (all, z) {
	        all[z.toUpperCase()] = z;
	        return all;
	    }, {});
	    var ianaTimeZone = UPPERCASED_LINKS[uppercasedTz] || uppercasedZones[uppercasedTz];
	    if (ianaTimeZone === 'Etc/UTC' || ianaTimeZone === 'Etc/GMT') {
	        return 'UTC';
	    }
	    return ianaTimeZone;
	}
	function isTimeRelated(opt) {
	    for (var _i = 0, _a = ['hour', 'minute', 'second']; _i < _a.length; _i++) {
	        var prop = _a[_i];
	        var value = opt[prop];
	        if (value !== undefined) {
	            return true;
	        }
	    }
	    return false;
	}
	/**
	 * https://tc39.es/ecma402/#sec-initializedatetimeformat
	 * @param dtf DateTimeFormat
	 * @param locales locales
	 * @param opts options
	 */
	function initializeDateTimeFormat(dtf, locales, opts) {
	    // @ts-ignore
	    var requestedLocales = Intl.getCanonicalLocales(locales);
	    var options = toDateTimeOptions(opts, 'any', 'date');
	    var opt = Object.create(null);
	    var matcher = GetOption(options, 'localeMatcher', 'string', ['lookup', 'best fit'], 'best fit');
	    opt.localeMatcher = matcher;
	    var calendar = GetOption(options, 'calendar', 'string', undefined, undefined);
	    if (calendar !== undefined && !TYPE_REGEX.test(calendar)) {
	        throw new RangeError('Malformed calendar');
	    }
	    var internalSlots = getInternalSlots(dtf);
	    opt.ca = calendar;
	    var numberingSystem = GetOption(options, 'numberingSystem', 'string', undefined, undefined);
	    if (numberingSystem !== undefined && !TYPE_REGEX.test(numberingSystem)) {
	        throw new RangeError('Malformed numbering system');
	    }
	    opt.nu = numberingSystem;
	    var hour12 = GetOption(options, 'hour12', 'boolean', undefined, undefined);
	    var hourCycle = GetOption(options, 'hourCycle', 'string', ['h11', 'h12', 'h23', 'h24'], undefined);
	    if (hour12 !== undefined) {
	        // @ts-ignore
	        hourCycle = null;
	    }
	    opt.hc = hourCycle;
	    var r = ResolveLocale(DateTimeFormat.availableLocales, requestedLocales, 
	    // TODO: Fix the type
	    opt, 
	    // [[RelevantExtensionKeys]] slot, which is a constant
	    ['nu', 'ca', 'hc'], DateTimeFormat.localeData, DateTimeFormat.getDefaultLocale);
	    internalSlots.locale = r.locale;
	    calendar = r.ca;
	    internalSlots.calendar = calendar;
	    internalSlots.hourCycle = r.hc;
	    internalSlots.numberingSystem = r.nu;
	    var dataLocale = r.dataLocale;
	    internalSlots.dataLocale = dataLocale;
	    var timeZone = options.timeZone;
	    if (timeZone !== undefined) {
	        timeZone = String(timeZone);
	        if (!isValidTimeZoneName(timeZone)) {
	            throw new RangeError('Invalid timeZoneName');
	        }
	        timeZone = canonicalizeTimeZoneName(timeZone);
	    }
	    else {
	        timeZone = DateTimeFormat.getDefaultTimeZone();
	    }
	    internalSlots.timeZone = timeZone;
	    opt = Object.create(null);
	    opt.weekday = GetOption(options, 'weekday', 'string', ['narrow', 'short', 'long'], undefined);
	    opt.era = GetOption(options, 'era', 'string', ['narrow', 'short', 'long'], undefined);
	    opt.year = GetOption(options, 'year', 'string', ['2-digit', 'numeric'], undefined);
	    opt.month = GetOption(options, 'month', 'string', ['2-digit', 'numeric', 'narrow', 'short', 'long'], undefined);
	    opt.day = GetOption(options, 'day', 'string', ['2-digit', 'numeric'], undefined);
	    opt.hour = GetOption(options, 'hour', 'string', ['2-digit', 'numeric'], undefined);
	    opt.minute = GetOption(options, 'minute', 'string', ['2-digit', 'numeric'], undefined);
	    opt.second = GetOption(options, 'second', 'string', ['2-digit', 'numeric'], undefined);
	    opt.timeZoneName = GetOption(options, 'timeZoneName', 'string', ['short', 'long'], undefined);
	    var dataLocaleData = DateTimeFormat.localeData[dataLocale];
	    var formats = dataLocaleData.formats[calendar];
	    matcher = GetOption(options, 'formatMatcher', 'string', ['basic', 'best fit'], 'best fit');
	    var dateStyle = GetOption(options, 'dateStyle', 'string', ['full', 'long', 'medium', 'short'], undefined);
	    internalSlots.dateStyle = dateStyle;
	    var timeStyle = GetOption(options, 'timeStyle', 'string', ['full', 'long', 'medium', 'short'], undefined);
	    internalSlots.timeStyle = timeStyle;
	    var bestFormat;
	    if (dateStyle === undefined && timeStyle === undefined) {
	        if (matcher === 'basic') {
	            bestFormat = basicFormatMatcher(opt, formats);
	        }
	        else {
	            if (isTimeRelated(opt)) {
	                opt.hour12 =
	                    internalSlots.hourCycle === 'h11' ||
	                        internalSlots.hourCycle === 'h12';
	            }
	            bestFormat = bestFitFormatMatcher(opt, formats);
	        }
	    }
	    else {
	        for (var _i = 0, DATE_TIME_PROPS_1 = DATE_TIME_PROPS; _i < DATE_TIME_PROPS_1.length; _i++) {
	            var prop = DATE_TIME_PROPS_1[_i];
	            var p = opt[prop];
	            if (p !== undefined) {
	                throw new TypeError("Intl.DateTimeFormat can't set option " + prop + " when " + (dateStyle ? 'dateStyle' : 'timeStyle') + " is used");
	            }
	        }
	        bestFormat = dateTimeStyleFormat(dateStyle, timeStyle, dataLocaleData);
	    }
	    for (var prop in opt) {
	        var p = bestFormat[prop];
	        if (p !== undefined) {
	            internalSlots[prop] = p;
	        }
	    }
	    var pattern;
	    if (internalSlots.hour !== undefined) {
	        var hcDefault = dataLocaleData.hourCycle;
	        var hc = internalSlots.hourCycle;
	        if (hc == null) {
	            hc = hcDefault;
	        }
	        if (hour12 !== undefined) {
	            if (hour12) {
	                if (hcDefault === 'h11' || hcDefault === 'h23') {
	                    hc = 'h11';
	                }
	                else {
	                    hc = 'h12';
	                }
	            }
	            else {
	                invariant(!hour12, 'hour12 must not be set');
	                if (hcDefault === 'h11' || hcDefault === 'h23') {
	                    hc = 'h23';
	                }
	                else {
	                    hc = 'h24';
	                }
	            }
	        }
	        internalSlots.hourCycle = hc;
	        if (hc === 'h11' || hc === 'h12') {
	            pattern = bestFormat.pattern12;
	        }
	        else {
	            pattern = bestFormat.pattern;
	        }
	    }
	    else {
	        // @ts-ignore
	        internalSlots.hourCycle = undefined;
	        pattern = bestFormat.pattern;
	    }
	    internalSlots.pattern = pattern;
	    return dtf;
	}
	/**
	 * https://tc39.es/ecma402/#sec-todatetimeoptions
	 * @param options
	 * @param required
	 * @param defaults
	 */
	function toDateTimeOptions(options, required, defaults) {
	    if (options === undefined) {
	        options = null;
	    }
	    else {
	        options = ToObject(options);
	    }
	    options = Object.create(options);
	    var needDefaults = true;
	    if (required === 'date' || required === 'any') {
	        for (var _i = 0, _a = ['weekday', 'year', 'month', 'day']; _i < _a.length; _i++) {
	            var prop = _a[_i];
	            var value = options[prop];
	            if (value !== undefined) {
	                needDefaults = false;
	            }
	        }
	    }
	    if (required === 'time' || required === 'any') {
	        for (var _b = 0, _c = ['hour', 'minute', 'second']; _b < _c.length; _b++) {
	            var prop = _c[_b];
	            var value = options[prop];
	            if (value !== undefined) {
	                needDefaults = false;
	            }
	        }
	    }
	    if (options.dateStyle !== undefined || options.timeStyle !== undefined) {
	        needDefaults = false;
	    }
	    if (required === 'date' && options.timeStyle) {
	        throw new TypeError('Intl.DateTimeFormat date was required but timeStyle was included');
	    }
	    if (required === 'time' && options.dateStyle) {
	        throw new TypeError('Intl.DateTimeFormat time was required but dateStyle was included');
	    }
	    if (needDefaults && (defaults === 'date' || defaults === 'all')) {
	        for (var _d = 0, _e = ['year', 'month', 'day']; _d < _e.length; _d++) {
	            var prop = _e[_d];
	            options[prop] = 'numeric';
	        }
	    }
	    if (needDefaults && (defaults === 'time' || defaults === 'all')) {
	        for (var _f = 0, _g = ['hour', 'minute', 'second']; _f < _g.length; _f++) {
	            var prop = _g[_f];
	            options[prop] = 'numeric';
	        }
	    }
	    return options;
	}
	var BASIC_FORMAT_MATCHER_VALUES = [
	    '2-digit',
	    'numeric',
	    'narrow',
	    'short',
	    'long',
	];
	var removalPenalty = 120;
	var additionPenalty = 20;
	var differentNumericTypePenalty = 15;
	var longLessPenalty = 8;
	var longMorePenalty = 6;
	var shortLessPenalty = 6;
	var shortMorePenalty = 3;
	function basicFormatMatcherScore(options, format) {
	    var score = 0;
	    for (var _i = 0, DATE_TIME_PROPS_2 = DATE_TIME_PROPS; _i < DATE_TIME_PROPS_2.length; _i++) {
	        var prop = DATE_TIME_PROPS_2[_i];
	        var optionsProp = options[prop];
	        var formatProp = format[prop];
	        if (optionsProp === undefined && formatProp !== undefined) {
	            score -= additionPenalty;
	        }
	        else if (optionsProp !== undefined && formatProp === undefined) {
	            score -= removalPenalty;
	        }
	        else if (optionsProp !== formatProp) {
	            var optionsPropIndex = BASIC_FORMAT_MATCHER_VALUES.indexOf(optionsProp);
	            var formatPropIndex = BASIC_FORMAT_MATCHER_VALUES.indexOf(formatProp);
	            var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));
	            if (delta === 2) {
	                score -= longMorePenalty;
	            }
	            else if (delta === 1) {
	                score -= shortMorePenalty;
	            }
	            else if (delta === -1) {
	                score -= shortLessPenalty;
	            }
	            else if (delta === -2) {
	                score -= longLessPenalty;
	            }
	        }
	    }
	    return score;
	}
	/**
	 * Credit: https://github.com/andyearnshaw/Intl.js/blob/0958dc1ad8153f1056653ea22b8208f0df289a4e/src/12.datetimeformat.js#L611
	 * with some modifications
	 * @param options
	 * @param format
	 */
	function bestFitFormatMatcherScore(options, format) {
	    var score = 0;
	    if (options.hour12 && !format.hour12) {
	        score -= removalPenalty;
	    }
	    else if (!options.hour12 && format.hour12) {
	        score -= additionPenalty;
	    }
	    for (var _i = 0, DATE_TIME_PROPS_3 = DATE_TIME_PROPS; _i < DATE_TIME_PROPS_3.length; _i++) {
	        var prop = DATE_TIME_PROPS_3[_i];
	        var optionsProp = options[prop];
	        var formatProp = format[prop];
	        if (optionsProp === undefined && formatProp !== undefined) {
	            score -= additionPenalty;
	        }
	        else if (optionsProp !== undefined && formatProp === undefined) {
	            score -= removalPenalty;
	        }
	        else if (optionsProp !== formatProp) {
	            // extra penalty for numeric vs non-numeric
	            if (isNumericType(optionsProp) !==
	                isNumericType(formatProp)) {
	                score -= differentNumericTypePenalty;
	            }
	            else {
	                var optionsPropIndex = BASIC_FORMAT_MATCHER_VALUES.indexOf(optionsProp);
	                var formatPropIndex = BASIC_FORMAT_MATCHER_VALUES.indexOf(formatProp);
	                var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));
	                if (delta === 2) {
	                    score -= longMorePenalty;
	                }
	                else if (delta === 1) {
	                    score -= shortMorePenalty;
	                }
	                else if (delta === -1) {
	                    score -= shortLessPenalty;
	                }
	                else if (delta === -2) {
	                    score -= longLessPenalty;
	                }
	            }
	        }
	    }
	    return score;
	}
	function dateTimeStyleFormat(dateStyle, timeStyle, dataLocaleData) {
	    var dateFormat, timeFormat;
	    if (timeStyle !== undefined) {
	        timeFormat = dataLocaleData.timeFormat[timeStyle];
	    }
	    if (dateStyle !== undefined) {
	        dateFormat = dataLocaleData.dateFormat[dateStyle];
	    }
	    if (dateStyle !== undefined &&
	        dateFormat !== undefined &&
	        timeFormat !== undefined) {
	        var format = __assign$1(__assign$1({}, dateFormat), timeFormat);
	        delete format.pattern;
	        delete format.pattern12;
	        var connector = dataLocaleData.dateTimeFormat[dateStyle];
	        format.pattern = connector
	            .replace('{0}', timeFormat.pattern)
	            .replace('{1}', dateFormat.pattern);
	        if (timeFormat.pattern12 !== undefined) {
	            format.pattern12 = connector
	                .replace('{0}', timeFormat.pattern12)
	                .replace('{1}', dateFormat.pattern);
	        }
	        return format;
	    }
	    if (timeFormat !== undefined) {
	        return timeFormat;
	    }
	    if (dateFormat === undefined) {
	        throw new TypeError('Intl.DateTimeFormat neither the dateFormat or the timeFormat could be found');
	    }
	    return dateFormat;
	}
	/**
	 * https://tc39.es/ecma402/#sec-basicformatmatcher
	 * @param options
	 * @param formats
	 */
	function basicFormatMatcher(options, formats) {
	    var bestScore = -Infinity;
	    var bestFormat = formats[0];
	    invariant(Array.isArray(formats), 'formats should be a list of things');
	    for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {
	        var format = formats_1[_i];
	        var score = basicFormatMatcherScore(options, format);
	        if (score > bestScore) {
	            bestScore = score;
	            bestFormat = format;
	        }
	    }
	    return __assign$1({}, bestFormat);
	}
	function isNumericType(t) {
	    return t === 'numeric' || t === '2-digit';
	}
	/**
	 * https://tc39.es/ecma402/#sec-bestfitformatmatcher
	 * Just alias to basic for now
	 * @param options
	 * @param formats
	 */
	function bestFitFormatMatcher(options, formats) {
	    var bestScore = -Infinity;
	    var bestFormat = formats[0];
	    invariant(Array.isArray(formats), 'formats should be a list of things');
	    for (var _i = 0, formats_2 = formats; _i < formats_2.length; _i++) {
	        var format = formats_2[_i];
	        var score = bestFitFormatMatcherScore(options, format);
	        if (score > bestScore) {
	            bestScore = score;
	            bestFormat = format;
	        }
	    }
	    var skeletonFormat = __assign$1({}, bestFormat);
	    var patternFormat = parseDateTimeSkeleton(bestFormat.rawPattern);
	    // Kinda following https://github.com/unicode-org/icu/blob/dd50e38f459d84e9bf1b0c618be8483d318458ad/icu4j/main/classes/core/src/com/ibm/icu/text/DateTimePatternGenerator.java
	    // Method adjustFieldTypes
	    for (var prop in patternFormat) {
	        var skeletonValue = skeletonFormat[prop];
	        var patternValue = patternFormat[prop];
	        var requestedValue = options[prop];
	        // Don't mess with minute/second or we can get in the situation of
	        // 7:0:0 which is weird
	        if (prop === 'minute' || prop === 'second') {
	            continue;
	        }
	        // Nothing to do here
	        if (!requestedValue) {
	            continue;
	        }
	        // https://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons
	        // Looks like we should not convert numeric to alphabetic but the other way
	        // around is ok
	        if (isNumericType(patternValue) &&
	            !isNumericType(requestedValue)) {
	            continue;
	        }
	        if (skeletonValue === requestedValue) {
	            continue;
	        }
	        patternFormat[prop] = requestedValue;
	    }
	    return patternFormat;
	}
	var formatDescriptor = {
	    enumerable: false,
	    configurable: true,
	    get: function () {
	        if (typeof this !== 'object' || !(this instanceof DateTimeFormat)) {
	            throw TypeError('Intl.DateTimeFormat format property accessor called on incompatible receiver');
	        }
	        var internalSlots = getInternalSlots(this);
	        // eslint-disable-next-line @typescript-eslint/no-this-alias
	        var dtf = this;
	        var boundFormat = internalSlots.boundFormat;
	        if (boundFormat === undefined) {
	            // https://tc39.es/proposal-unified-intl-numberformat/section11/numberformat_diff_out.html#sec-number-format-functions
	            boundFormat = function (date) {
	                var x;
	                if (date === undefined) {
	                    x = Date.now();
	                }
	                else {
	                    x = Number(date);
	                }
	                return formatDateTime(dtf, x);
	            };
	            try {
	                // https://github.com/tc39/test262/blob/master/test/intl402/NumberFormat/prototype/format/format-function-name.js
	                Object.defineProperty(boundFormat, 'name', {
	                    configurable: true,
	                    enumerable: false,
	                    writable: false,
	                    value: '',
	                });
	            }
	            catch (e) {
	                // In older browser (e.g Chrome 36 like polyfill.io)
	                // TypeError: Cannot redefine property: name
	            }
	            internalSlots.boundFormat = boundFormat;
	        }
	        return boundFormat;
	    },
	};
	try {
	    // https://github.com/tc39/test262/blob/master/test/intl402/NumberFormat/prototype/format/name.js
	    Object.defineProperty(formatDescriptor.get, 'name', {
	        configurable: true,
	        enumerable: false,
	        writable: false,
	        value: 'get format',
	    });
	}
	catch (e) {
	    // In older browser (e.g Chrome 36 like polyfill.io)
	    // TypeError: Cannot redefine property: name
	}
	function pad(n) {
	    if (n < 10) {
	        return "0" + n;
	    }
	    return String(n);
	}
	function offsetToGmtString(gmtFormat, hourFormat, offsetInMs, style) {
	    var offsetInMinutes = Math.floor(offsetInMs / 60000);
	    var mins = Math.abs(offsetInMinutes) % 60;
	    var hours = Math.floor(Math.abs(offsetInMinutes) / 60);
	    var _a = hourFormat.split(';'), positivePattern = _a[0], negativePattern = _a[1];
	    var offsetStr = '';
	    var pattern = offsetInMs < 0 ? negativePattern : positivePattern;
	    if (style === 'long') {
	        offsetStr = pattern
	            .replace('HH', pad(hours))
	            .replace('H', String(hours))
	            .replace('mm', pad(mins))
	            .replace('m', String(mins));
	    }
	    else if (mins || hours) {
	        if (!mins) {
	            pattern = pattern.replace(/:?m+/, '');
	        }
	        offsetStr = pattern
	            .replace(/H+/, String(hours))
	            .replace(/m+/, String(mins));
	    }
	    return gmtFormat.replace('{0}', offsetStr);
	}
	/**
	 * https://tc39.es/ecma402/#sec-partitiondatetimepattern
	 * @param dtf
	 * @param x
	 */
	function partitionDateTimePattern(dtf, x) {
	    x = TimeClip(x);
	    if (isNaN(x)) {
	        throw new RangeError('invalid time');
	    }
	    /** IMPL START */
	    var internalSlots = getInternalSlots(dtf);
	    var dataLocale = internalSlots.dataLocale;
	    var dataLocaleData = DateTimeFormat.localeData[dataLocale];
	    /** IMPL END */
	    var locale = internalSlots.locale;
	    var nfOptions = Object.create(null);
	    nfOptions.useGrouping = false;
	    var nf = new Intl.NumberFormat(locale, nfOptions);
	    var nf2Options = Object.create(null);
	    nf2Options.minimumIntegerDigits = 2;
	    nf2Options.useGrouping = false;
	    var nf2 = new Intl.NumberFormat(locale, nf2Options);
	    var tm = toLocalTime(x, 
	    // @ts-ignore
	    internalSlots.calendar, internalSlots.timeZone);
	    var result = [];
	    var patternParts = PartitionPattern(internalSlots.pattern);
	    for (var _i = 0, patternParts_1 = patternParts; _i < patternParts_1.length; _i++) {
	        var patternPart = patternParts_1[_i];
	        var p = patternPart.type;
	        if (p === 'literal') {
	            result.push({
	                type: 'literal',
	                value: patternPart.value,
	            });
	        }
	        else if (DATE_TIME_PROPS.indexOf(p) > -1) {
	            var fv = '';
	            var f = internalSlots[p];
	            // @ts-ignore
	            var v = tm[p];
	            if (p === 'year' && v <= 0) {
	                v = 1 - v;
	            }
	            if (p === 'month') {
	                v++;
	            }
	            var hourCycle = internalSlots.hourCycle;
	            if (p === 'hour' && (hourCycle === 'h11' || hourCycle === 'h12')) {
	                v = v % 12;
	                if (v === 0 && hourCycle === 'h12') {
	                    v = 12;
	                }
	            }
	            if (p === 'hour' && hourCycle === 'h24') {
	                if (v === 0) {
	                    v = 24;
	                }
	            }
	            if (f === 'numeric') {
	                fv = nf.format(v);
	            }
	            else if (f === '2-digit') {
	                fv = nf2.format(v);
	                if (fv.length > 2) {
	                    fv = fv.slice(fv.length - 2, fv.length);
	                }
	            }
	            else if (f === 'narrow' || f === 'short' || f === 'long') {
	                if (p === 'era') {
	                    fv = dataLocaleData[p][f][v];
	                }
	                else if (p === 'timeZoneName') {
	                    var timeZoneName = dataLocaleData.timeZoneName, gmtFormat = dataLocaleData.gmtFormat, hourFormat = dataLocaleData.hourFormat;
	                    var timeZone = internalSlots.timeZone || DateTimeFormat.getDefaultTimeZone();
	                    var timeZoneData = timeZoneName[timeZone];
	                    if (timeZoneData && timeZoneData[f]) {
	                        fv = timeZoneData[f][+tm.inDST];
	                    }
	                    else {
	                        // Fallback to gmtFormat
	                        fv = offsetToGmtString(gmtFormat, hourFormat, tm.timeZoneOffset, f);
	                    }
	                }
	                else if (p === 'month') {
	                    fv = dataLocaleData.month[f][v - 1];
	                }
	                else {
	                    fv = dataLocaleData[p][f][v];
	                }
	            }
	            result.push({
	                type: p,
	                value: fv,
	            });
	        }
	        else if (p === 'ampm') {
	            var v = tm.hour;
	            var fv = void 0;
	            if (v >= 11) {
	                fv = dataLocaleData.pm;
	            }
	            else {
	                fv = dataLocaleData.am;
	            }
	            result.push({
	                type: 'dayPeriod',
	                value: fv,
	            });
	        }
	        else if (p === 'relatedYear') {
	            var v = tm.relatedYear;
	            // @ts-ignore
	            var fv = nf.format(v);
	            result.push({
	                type: 'relatedYear',
	                value: fv,
	            });
	        }
	        else if (p === 'yearName') {
	            var v = tm.yearName;
	            // @ts-ignore
	            var fv = nf.format(v);
	            result.push({
	                type: 'yearName',
	                value: fv,
	            });
	        }
	        else {
	            result.push({
	                type: 'unknown',
	                value: x,
	            });
	        }
	    }
	    return result;
	}
	/**
	 * https://tc39.es/ecma402/#sec-formatdatetime
	 * @param dtf DateTimeFormat
	 * @param x
	 */
	function formatDateTime(dtf, x) {
	    var parts = partitionDateTimePattern(dtf, x);
	    var result = '';
	    for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
	        var part = parts_1[_i];
	        result += part.value;
	    }
	    return result;
	}
	/**
	 * https://tc39.es/ecma402/#sec-formatdatetimetoparts
	 * @param dtf DateTimeFormat
	 * @param x
	 */
	function formatDateTimeParts(dtf, x) {
	    return partitionDateTimePattern(dtf, x);
	}
	function getApplicableZoneData(t, timeZone) {
	    var _a;
	    var tzData = DateTimeFormat.tzData;
	    var zoneData = tzData[timeZone];
	    // We don't have data for this so just say it's UTC
	    if (!zoneData) {
	        return [0, false];
	    }
	    var i = 0;
	    var offset = 0;
	    var dst = false;
	    for (; i <= zoneData.length; i++) {
	        if (i === zoneData.length || zoneData[i][0] * 1e3 >= t) {
	            _a = zoneData[i - 1], offset = _a[2], dst = _a[3];
	            break;
	        }
	    }
	    return [offset * 1e3, dst];
	}
	/**
	 * https://tc39.es/ecma402/#sec-tolocaltime
	 * @param t
	 * @param calendar
	 * @param timeZone
	 */
	function toLocalTime(t, calendar, timeZone) {
	    invariant(typeof t === 'number', 'invalid time');
	    invariant(calendar === 'gregory', 'We only support Gregory calendar right now');
	    var _a = getApplicableZoneData(t, timeZone), timeZoneOffset = _a[0], inDST = _a[1];
	    var tz = t + timeZoneOffset;
	    var year = YearFromTime(tz);
	    return {
	        weekday: WeekDay(tz),
	        era: year < 0 ? 'BC' : 'AD',
	        year: year,
	        relatedYear: undefined,
	        yearName: undefined,
	        month: MonthFromTime(tz),
	        day: DateFromTime(tz),
	        hour: HourFromTime(tz),
	        minute: MinFromTime(tz),
	        second: SecFromTime(tz),
	        inDST: inDST,
	        // IMPORTANT: Not in spec
	        timeZoneOffset: timeZoneOffset,
	    };
	}
	var DateTimeFormat = function (locales, options) {
	    // Cannot use `new.target` bc of IE11 & TS transpiles it to something else
	    if (!this || !(this instanceof DateTimeFormat)) {
	        return new DateTimeFormat(locales, options);
	    }
	    initializeDateTimeFormat(this, locales, options);
	    /** IMPL START */
	    var internalSlots = getInternalSlots(this);
	    var dataLocale = internalSlots.dataLocale;
	    var dataLocaleData = DateTimeFormat.localeData[dataLocale];
	    invariant(dataLocaleData !== undefined, "Cannot load locale-dependent data for " + dataLocale + ".");
	    /** IMPL END */
	};
	// Static properties
	defineProperty(DateTimeFormat, 'supportedLocalesOf', {
	    value: function supportedLocalesOf(locales, options) {
	        return SupportedLocales(DateTimeFormat.availableLocales, Intl.getCanonicalLocales(locales), options);
	    },
	});
	defineProperty(DateTimeFormat.prototype, 'resolvedOptions', {
	    value: function resolvedOptions() {
	        if (typeof this !== 'object' || !(this instanceof DateTimeFormat)) {
	            throw TypeError('Method Intl.DateTimeFormat.prototype.resolvedOptions called on incompatible receiver');
	        }
	        var internalSlots = getInternalSlots(this);
	        var ro = {};
	        for (var _i = 0, RESOLVED_OPTIONS_KEYS_1 = RESOLVED_OPTIONS_KEYS; _i < RESOLVED_OPTIONS_KEYS_1.length; _i++) {
	            var key = RESOLVED_OPTIONS_KEYS_1[_i];
	            var value = internalSlots[key];
	            if (key === 'hourCycle') {
	                var hour12 = value === 'h11' || value === 'h12'
	                    ? true
	                    : value === 'h23' || value === 'h24'
	                        ? false
	                        : undefined;
	                if (hour12 !== undefined) {
	                    ro.hour12 = hour12;
	                }
	            }
	            if (DATE_TIME_PROPS.indexOf(key) > -1) {
	                if (internalSlots.dateStyle !== undefined ||
	                    internalSlots.timeStyle !== undefined) {
	                    value = undefined;
	                }
	            }
	            if (value !== undefined) {
	                ro[key] = value;
	            }
	        }
	        return ro;
	    },
	});
	defineProperty(DateTimeFormat.prototype, 'formatToParts', {
	    value: function formatToParts(date) {
	        if (date === undefined) {
	            date = Date.now();
	        }
	        else {
	            date = ToNumber(date);
	        }
	        return formatDateTimeParts(this, date);
	    },
	});
	var DEFAULT_TIMEZONE = (typeof process !== 'undefined' && process.env && process.env.TZ) || 'UTC';
	DateTimeFormat.__setDefaultTimeZone = function (timeZone) {
	    if (timeZone !== undefined) {
	        timeZone = String(timeZone);
	        if (!isValidTimeZoneName(timeZone)) {
	            throw new RangeError('Invalid timeZoneName');
	        }
	        timeZone = canonicalizeTimeZoneName(timeZone);
	    }
	    else {
	        timeZone = DEFAULT_TIMEZONE;
	    }
	    DateTimeFormat.__defaultTimeZone = timeZone;
	};
	DateTimeFormat.__defaultTimeZone = DEFAULT_TIMEZONE;
	DateTimeFormat.getDefaultTimeZone = function () { return DateTimeFormat.__defaultTimeZone; };
	DateTimeFormat.__addLocaleData = function __addLocaleData() {
	    var data = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        data[_i] = arguments[_i];
	    }
	    for (var _a = 0, data_1 = data; _a < data_1.length; _a++) {
	        var datum = data_1[_a];
	        var availableLocales = datum.availableLocales;
	        var _loop_1 = function (locale) {
	            try {
	                var _a = unpackData(locale, datum), dateFormat = _a.dateFormat, timeFormat = _a.timeFormat, dateTimeFormat = _a.dateTimeFormat, formats_3 = _a.formats, rawData = __rest(_a, ["dateFormat", "timeFormat", "dateTimeFormat", "formats"]);
	                var processedData = __assign$1(__assign$1({}, rawData), { dateFormat: {
	                        full: parseDateTimeSkeleton(dateFormat.full),
	                        long: parseDateTimeSkeleton(dateFormat.long),
	                        medium: parseDateTimeSkeleton(dateFormat.medium),
	                        short: parseDateTimeSkeleton(dateFormat.short),
	                    }, timeFormat: {
	                        full: parseDateTimeSkeleton(timeFormat.full),
	                        long: parseDateTimeSkeleton(timeFormat.long),
	                        medium: parseDateTimeSkeleton(timeFormat.medium),
	                        short: parseDateTimeSkeleton(timeFormat.short),
	                    }, dateTimeFormat: {
	                        full: parseDateTimeSkeleton(dateTimeFormat.full).pattern,
	                        long: parseDateTimeSkeleton(dateTimeFormat.long).pattern,
	                        medium: parseDateTimeSkeleton(dateTimeFormat.medium).pattern,
	                        short: parseDateTimeSkeleton(dateTimeFormat.short).pattern,
	                    }, formats: {} });
	                var _loop_2 = function (calendar) {
	                    processedData.formats[calendar] = Object.keys(formats_3[calendar]).map(function (skeleton) {
	                        return parseDateTimeSkeleton(skeleton, formats_3[calendar][skeleton]);
	                    });
	                };
	                for (var calendar in formats_3) {
	                    _loop_2(calendar);
	                }
	                DateTimeFormat.localeData[locale] = processedData;
	            }
	            catch (e) {
	                // Ignore if we got no data
	            }
	        };
	        for (var _b = 0, availableLocales_1 = availableLocales; _b < availableLocales_1.length; _b++) {
	            var locale = availableLocales_1[_b];
	            _loop_1(locale);
	        }
	    }
	    DateTimeFormat.availableLocales = Object.keys(DateTimeFormat.localeData);
	    if (!DateTimeFormat.__defaultLocale) {
	        DateTimeFormat.__defaultLocale = DateTimeFormat.availableLocales[0];
	    }
	};
	Object.defineProperty(DateTimeFormat.prototype, 'format', formatDescriptor);
	DateTimeFormat.__defaultLocale = '';
	DateTimeFormat.localeData = {};
	DateTimeFormat.availableLocales = [];
	DateTimeFormat.getDefaultLocale = function () {
	    return DateTimeFormat.__defaultLocale;
	};
	DateTimeFormat.polyfilled = true;
	DateTimeFormat.tzData = {};
	DateTimeFormat.__addTZData = function (d) {
	    DateTimeFormat.tzData = unpack(d);
	};
	try {
	    if (typeof Symbol !== 'undefined') {
	        Object.defineProperty(DateTimeFormat.prototype, Symbol.toStringTag, {
	            value: 'Intl.DateTimeFormat',
	            writable: false,
	            enumerable: false,
	            configurable: true,
	        });
	    }
	    Object.defineProperty(DateTimeFormat.prototype.constructor, 'length', {
	        value: 1,
	        writable: false,
	        enumerable: false,
	        configurable: true,
	    });
	}
	catch (e) {
	    // Meta fix so we're test262-compliant, not important
	}

	function supportsDateStyle() {
	    return !!new Intl.DateTimeFormat(undefined, {
	        dateStyle: 'short',
	    }).resolvedOptions().dateStyle;
	}
	/**
	 * https://bugs.chromium.org/p/chromium/issues/detail?id=865351
	 */
	function hasChromeLt71Bug() {
	    return (new Intl.DateTimeFormat('en', {
	        hourCycle: 'h11',
	        hour: 'numeric',
	    }).formatToParts(0)[2].type !== 'dayPeriod');
	}
	function shouldPolyfill() {
	    return (!('DateTimeFormat' in Intl) ||
	        !('formatToParts' in Intl.DateTimeFormat.prototype) ||
	        hasChromeLt71Bug() ||
	        !supportsDateStyle());
	}

	// eslint-disable-next-line import/no-cycle
	/**
	 * Number.prototype.toLocaleString ponyfill
	 * https://tc39.es/ecma402/#sup-number.prototype.tolocalestring
	 */
	function toLocaleString(x, locales, options) {
	    var dtf = new DateTimeFormat(locales, options);
	    return dtf.format(x);
	}
	function toLocaleDateString(x, locales, options) {
	    var dtf = new DateTimeFormat(locales, toDateTimeOptions(options, 'date', 'date'));
	    return dtf.format(x);
	}
	function toLocaleTimeString(x, locales, options) {
	    var dtf = new DateTimeFormat(locales, toDateTimeOptions(options, 'time', 'time'));
	    return dtf.format(x);
	}

	if (shouldPolyfill()) {
	    defineProperty(Intl, 'DateTimeFormat', { value: DateTimeFormat });
	    defineProperty(Date.prototype, 'toLocaleString', {
	        value: function toLocaleString$1(locales, options) {
	            return toLocaleString(this, locales, options);
	        },
	    });
	    defineProperty(Date.prototype, 'toLocaleDateString', {
	        value: function toLocaleDateString$1(locales, options) {
	            return toLocaleDateString(this, locales, options);
	        },
	    });
	    defineProperty(Date.prototype, 'toLocaleTimeString', {
	        value: function toLocaleTimeString$1(locales, options) {
	            return toLocaleTimeString(this, locales, options);
	        },
	    });
	}

})));
//# sourceMappingURL=polyfill.umd.js.map
