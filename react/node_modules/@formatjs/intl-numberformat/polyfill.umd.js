(function (factory) {
    typeof define === 'function' && define.amd ? define(factory) :
    factory();
}((function () { 'use strict';

    /**
     * https://tc39.es/ecma402/#sec-defaultnumberoption
     * @param val
     * @param min
     * @param max
     * @param fallback
     */
    function DefaultNumberOption(val, min, max, fallback) {
        if (val !== undefined) {
            val = Number(val);
            if (isNaN(val) || val < min || val > max) {
                throw new RangeError(val + " is outside of range [" + min + ", " + max + "]");
            }
            return Math.floor(val);
        }
        return fallback;
    }

    /**
     * https://tc39.es/ecma402/#sec-getnumberoption
     * @param options
     * @param property
     * @param min
     * @param max
     * @param fallback
     */
    function GetNumberOption(options, property, minimum, maximum, fallback) {
        var val = options[property];
        return DefaultNumberOption(val, minimum, maximum, fallback);
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    	  path: basedir,
    	  exports: {},
    	  require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
        }
    	}, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    /* eslint complexity: [2, 18], max-statements: [2, 33] */
    var shams = function hasSymbols() {
    	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
    	if (typeof Symbol.iterator === 'symbol') { return true; }

    	var obj = {};
    	var sym = Symbol('test');
    	var symObj = Object(sym);
    	if (typeof sym === 'string') { return false; }

    	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
    	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

    	// temp disabled per https://github.com/ljharb/object.assign/issues/17
    	// if (sym instanceof Symbol) { return false; }
    	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    	// if (!(symObj instanceof Symbol)) { return false; }

    	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
    	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

    	var symVal = 42;
    	obj[sym] = symVal;
    	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
    	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

    	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

    	var syms = Object.getOwnPropertySymbols(obj);
    	if (syms.length !== 1 || syms[0] !== sym) { return false; }

    	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

    	if (typeof Object.getOwnPropertyDescriptor === 'function') {
    		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
    	}

    	return true;
    };

    var origSymbol = commonjsGlobal.Symbol;


    var hasSymbols = function hasNativeSymbols() {
    	if (typeof origSymbol !== 'function') { return false; }
    	if (typeof Symbol !== 'function') { return false; }
    	if (typeof origSymbol('foo') !== 'symbol') { return false; }
    	if (typeof Symbol('bar') !== 'symbol') { return false; }

    	return shams();
    };

    /* eslint no-invalid-this: 1 */

    var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = '[object Function]';

    var implementation = function bind(that) {
        var target = this;
        if (typeof target !== 'function' || toStr.call(target) !== funcType) {
            throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);

        var bound;
        var binder = function () {
            if (this instanceof bound) {
                var result = target.apply(
                    this,
                    args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;
            } else {
                return target.apply(
                    that,
                    args.concat(slice.call(arguments))
                );
            }
        };

        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

        if (target.prototype) {
            var Empty = function Empty() {};
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }

        return bound;
    };

    var functionBind = Function.prototype.bind || implementation;

    /* globals
    	Atomics,
    	SharedArrayBuffer,
    */

    var undefined$1;

    var $TypeError = TypeError;

    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
    	try {
    		$gOPD({}, '');
    	} catch (e) {
    		$gOPD = null; // this is IE 8, which has a broken gOPD
    	}
    }

    var throwTypeError = function () { throw new $TypeError(); };
    var ThrowTypeError = $gOPD
    	? (function () {
    		try {
    			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    			arguments.callee; // IE 8 does not throw here
    			return throwTypeError;
    		} catch (calleeThrows) {
    			try {
    				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
    				return $gOPD(arguments, 'callee').get;
    			} catch (gOPDthrows) {
    				return throwTypeError;
    			}
    		}
    	}())
    	: throwTypeError;

    var hasSymbols$1 = hasSymbols();

    var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto
    var generatorFunction =  undefined$1;
    var asyncFunction =  undefined$1;
    var asyncGenFunction =  undefined$1;

    var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto(Uint8Array);

    var INTRINSICS = {
    	'%Array%': Array,
    	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
    	'%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer.prototype,
    	'%ArrayIteratorPrototype%': hasSymbols$1 ? getProto([][Symbol.iterator]()) : undefined$1,
    	'%ArrayPrototype%': Array.prototype,
    	'%ArrayProto_entries%': Array.prototype.entries,
    	'%ArrayProto_forEach%': Array.prototype.forEach,
    	'%ArrayProto_keys%': Array.prototype.keys,
    	'%ArrayProto_values%': Array.prototype.values,
    	'%AsyncFromSyncIteratorPrototype%': undefined$1,
    	'%AsyncFunction%': asyncFunction,
    	'%AsyncFunctionPrototype%':  undefined$1,
    	'%AsyncGenerator%':  undefined$1,
    	'%AsyncGeneratorFunction%': asyncGenFunction,
    	'%AsyncGeneratorPrototype%':  undefined$1,
    	'%AsyncIteratorPrototype%':  undefined$1,
    	'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
    	'%Boolean%': Boolean,
    	'%BooleanPrototype%': Boolean.prototype,
    	'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
    	'%DataViewPrototype%': typeof DataView === 'undefined' ? undefined$1 : DataView.prototype,
    	'%Date%': Date,
    	'%DatePrototype%': Date.prototype,
    	'%decodeURI%': decodeURI,
    	'%decodeURIComponent%': decodeURIComponent,
    	'%encodeURI%': encodeURI,
    	'%encodeURIComponent%': encodeURIComponent,
    	'%Error%': Error,
    	'%ErrorPrototype%': Error.prototype,
    	'%eval%': eval, // eslint-disable-line no-eval
    	'%EvalError%': EvalError,
    	'%EvalErrorPrototype%': EvalError.prototype,
    	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
    	'%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array.prototype,
    	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
    	'%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array.prototype,
    	'%Function%': Function,
    	'%FunctionPrototype%': Function.prototype,
    	'%Generator%':  undefined$1,
    	'%GeneratorFunction%': generatorFunction,
    	'%GeneratorPrototype%':  undefined$1,
    	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
    	'%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array.prototype,
    	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
    	'%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined$1 : Int8Array.prototype,
    	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
    	'%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array.prototype,
    	'%isFinite%': isFinite,
    	'%isNaN%': isNaN,
    	'%IteratorPrototype%': hasSymbols$1 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    	'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
    	'%JSONParse%': typeof JSON === 'object' ? JSON.parse : undefined$1,
    	'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
    	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
    	'%MapPrototype%': typeof Map === 'undefined' ? undefined$1 : Map.prototype,
    	'%Math%': Math,
    	'%Number%': Number,
    	'%NumberPrototype%': Number.prototype,
    	'%Object%': Object,
    	'%ObjectPrototype%': Object.prototype,
    	'%ObjProto_toString%': Object.prototype.toString,
    	'%ObjProto_valueOf%': Object.prototype.valueOf,
    	'%parseFloat%': parseFloat,
    	'%parseInt%': parseInt,
    	'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
    	'%PromisePrototype%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype,
    	'%PromiseProto_then%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype.then,
    	'%Promise_all%': typeof Promise === 'undefined' ? undefined$1 : Promise.all,
    	'%Promise_reject%': typeof Promise === 'undefined' ? undefined$1 : Promise.reject,
    	'%Promise_resolve%': typeof Promise === 'undefined' ? undefined$1 : Promise.resolve,
    	'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
    	'%RangeError%': RangeError,
    	'%RangeErrorPrototype%': RangeError.prototype,
    	'%ReferenceError%': ReferenceError,
    	'%ReferenceErrorPrototype%': ReferenceError.prototype,
    	'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
    	'%RegExp%': RegExp,
    	'%RegExpPrototype%': RegExp.prototype,
    	'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
    	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols$1 ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
    	'%SetPrototype%': typeof Set === 'undefined' ? undefined$1 : Set.prototype,
    	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
    	'%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer.prototype,
    	'%String%': String,
    	'%StringIteratorPrototype%': hasSymbols$1 ? getProto(''[Symbol.iterator]()) : undefined$1,
    	'%StringPrototype%': String.prototype,
    	'%Symbol%': hasSymbols$1 ? Symbol : undefined$1,
    	'%SymbolPrototype%': hasSymbols$1 ? Symbol.prototype : undefined$1,
    	'%SyntaxError%': SyntaxError,
    	'%SyntaxErrorPrototype%': SyntaxError.prototype,
    	'%ThrowTypeError%': ThrowTypeError,
    	'%TypedArray%': TypedArray,
    	'%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined$1,
    	'%TypeError%': $TypeError,
    	'%TypeErrorPrototype%': $TypeError.prototype,
    	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
    	'%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array.prototype,
    	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
    	'%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray.prototype,
    	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
    	'%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array.prototype,
    	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
    	'%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array.prototype,
    	'%URIError%': URIError,
    	'%URIErrorPrototype%': URIError.prototype,
    	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
    	'%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap.prototype,
    	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,
    	'%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet.prototype
    };


    var $replace = functionBind.call(Function.call, String.prototype.replace);

    /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
    var stringToPath = function stringToPath(string) {
    	var result = [];
    	$replace(string, rePropName, function (match, number, quote, subString) {
    		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : (number || match);
    	});
    	return result;
    };
    /* end adaptation */

    var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    	if (!(name in INTRINSICS)) {
    		throw new SyntaxError('intrinsic ' + name + ' does not exist!');
    	}

    	// istanbul ignore if // hopefully this is impossible to test :-)
    	if (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {
    		throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    	}

    	return INTRINSICS[name];
    };

    var GetIntrinsic = function GetIntrinsic(name, allowMissing) {
    	if (typeof name !== 'string' || name.length === 0) {
    		throw new TypeError('intrinsic name must be a non-empty string');
    	}
    	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    		throw new TypeError('"allowMissing" argument must be a boolean');
    	}

    	var parts = stringToPath(name);

    	var value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);
    	for (var i = 1; i < parts.length; i += 1) {
    		if (value != null) {
    			if ($gOPD && (i + 1) >= parts.length) {
    				var desc = $gOPD(value, parts[i]);
    				if (!allowMissing && !(parts[i] in value)) {
    					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
    				}
    				value = desc ? (desc.get || desc.value) : value[parts[i]];
    			} else {
    				value = value[parts[i]];
    			}
    		}
    	}
    	return value;
    };

    var $String = GetIntrinsic('%String%');
    var $TypeError$1 = GetIntrinsic('%TypeError%');

    // https://www.ecma-international.org/ecma-262/6.0/#sec-tostring

    var ToString = function ToString(argument) {
    	if (typeof argument === 'symbol') {
    		throw new $TypeError$1('Cannot convert a Symbol value to a string');
    	}
    	return $String(argument);
    };

    /**
     * https://tc39.es/ecma402/#sec-getoption
     * @param opts
     * @param prop
     * @param type
     * @param values
     * @param fallback
     */
    function GetOption(opts, prop, type, values, fallback) {
        // const descriptor = Object.getOwnPropertyDescriptor(opts, prop);
        var value = opts[prop];
        if (value !== undefined) {
            if (type !== 'boolean' && type !== 'string') {
                throw new TypeError('invalid type');
            }
            if (type === 'boolean') {
                value = Boolean(value);
            }
            if (type === 'string') {
                value = ToString(value);
            }
            if (values !== undefined && !values.filter(function (val) { return val == value; }).length) {
                throw new RangeError(value + " is not within " + values.join(', '));
            }
            return value;
        }
        return fallback;
    }

    /**
     * https://tc39.es/ecma402/#table-sanctioned-simple-unit-identifiers
     */
    var SANCTIONED_UNITS = [
        'angle-degree',
        'area-acre',
        'area-hectare',
        'concentr-percent',
        'digital-bit',
        'digital-byte',
        'digital-gigabit',
        'digital-gigabyte',
        'digital-kilobit',
        'digital-kilobyte',
        'digital-megabit',
        'digital-megabyte',
        'digital-petabyte',
        'digital-terabit',
        'digital-terabyte',
        'duration-day',
        'duration-hour',
        'duration-millisecond',
        'duration-minute',
        'duration-month',
        'duration-second',
        'duration-week',
        'duration-year',
        'length-centimeter',
        'length-foot',
        'length-inch',
        'length-kilometer',
        'length-meter',
        'length-mile-scandinavian',
        'length-mile',
        'length-millimeter',
        'length-yard',
        'mass-gram',
        'mass-kilogram',
        'mass-ounce',
        'mass-pound',
        'mass-stone',
        'temperature-celsius',
        'temperature-fahrenheit',
        'volume-fluid-ounce',
        'volume-gallon',
        'volume-liter',
        'volume-milliliter',
    ];
    // In CLDR, the unit name always follows the form `namespace-unit` pattern.
    // For example: `digital-bit` instead of `bit`. This function removes the namespace prefix.
    function removeUnitNamespace(unit) {
        return unit.slice(unit.indexOf('-') + 1);
    }
    /**
     * https://tc39.es/ecma402/#table-sanctioned-simple-unit-identifiers
     */
    var SIMPLE_UNITS = SANCTIONED_UNITS.map(removeUnitNamespace);
    /**
     * https://tc39.es/ecma402/#sec-issanctionedsimpleunitidentifier
     */
    function IsSanctionedSimpleUnitIdentifier(unitIdentifier) {
        return SIMPLE_UNITS.indexOf(unitIdentifier) > -1;
    }

    /**
     * This follows https://tc39.es/ecma402/#sec-case-sensitivity-and-case-mapping
     * @param str string to convert
     */
    function toUpperCase(str) {
        return str.replace(/([a-z])/g, function (_, c) { return c.toUpperCase(); });
    }
    var NOT_A_Z_REGEX = /[^A-Z]/;
    /**
     * https://tc39.es/ecma402/#sec-iswellformedcurrencycode
     */
    function IsWellFormedCurrencyCode(currency) {
        currency = toUpperCase(currency);
        if (currency.length !== 3) {
            return false;
        }
        if (NOT_A_Z_REGEX.test(currency)) {
            return false;
        }
        return true;
    }

    /**
     * This follows https://tc39.es/ecma402/#sec-case-sensitivity-and-case-mapping
     * @param str string to convert
     */
    function toLowerCase(str) {
        return str.replace(/([A-Z])/g, function (_, c) { return c.toLowerCase(); });
    }
    /**
     * https://tc39.es/ecma402/#sec-iswellformedunitidentifier
     * @param unit
     */
    function IsWellFormedUnitIdentifier(unit) {
        unit = toLowerCase(unit);
        if (IsSanctionedSimpleUnitIdentifier(unit)) {
            return true;
        }
        var units = unit.split('-per-');
        if (units.length !== 2) {
            return false;
        }
        var numerator = units[0], denominator = units[1];
        if (!IsSanctionedSimpleUnitIdentifier(numerator) ||
            !IsSanctionedSimpleUnitIdentifier(denominator)) {
            return false;
        }
        return true;
    }

    var _isNaN = Number.isNaN || function isNaN(a) {
    	return a !== a;
    };

    // http://www.ecma-international.org/ecma-262/5.1/#sec-9.12

    var SameValue = function SameValue(x, y) {
    	if (x === y) { // 0 === -0, but they are not identical.
    		if (x === 0) { return 1 / x === 1 / y; }
    		return true;
    	}
    	return _isNaN(x) && _isNaN(y);
    };

    /**
     * Cannot do Math.log(x) / Math.log(10) bc if IEEE floating point issue
     * @param x number
     */
    function getMagnitude(x) {
        // Cannot count string length via Number.toString because it may use scientific notation
        // for very small or very large numbers.
        return Math.floor(Math.log(x) * Math.LOG10E);
    }
    function repeat(s, times) {
        if (typeof s.repeat === 'function') {
            return s.repeat(times);
        }
        var arr = new Array(times);
        for (var i = 0; i < arr.length; i++) {
            arr[i] = s;
        }
        return arr.join('');
    }
    /*
      17 ECMAScript Standard Built-in Objects:
        Every built-in Function object, including constructors, that is not
        identified as an anonymous function has a name property whose value
        is a String.

        Unless otherwise specified, the name property of a built-in Function
        object, if it exists, has the attributes { [[Writable]]: false,
        [[Enumerable]]: false, [[Configurable]]: true }.
    */
    function defineProperty(target, name, _a) {
        var value = _a.value;
        Object.defineProperty(target, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: value,
        });
    }
    var UNICODE_EXTENSION_SEQUENCE_REGEX = /-u(?:-[0-9a-z]{2,8})+/gi;
    function invariant(condition, message, Err) {
        if (Err === void 0) { Err = Error; }
        if (!condition) {
            throw new Err(message);
        }
    }

    function ToRawPrecision(x, minPrecision, maxPrecision) {
        var p = maxPrecision;
        var m;
        var e;
        var xFinal;
        if (x === 0) {
            m = repeat('0', p);
            e = 0;
            xFinal = 0;
        }
        else {
            var xToString = x.toString();
            // If xToString is formatted as scientific notation, the number is either very small or very
            // large. If the precision of the formatted string is lower that requested max precision, we
            // should still infer them from the formatted string, otherwise the formatted result might have
            // precision loss (e.g. 1e41 will not have 0 in every trailing digits).
            var xToStringExponentIndex = xToString.indexOf('e');
            var _a = xToString.split('e'), xToStringMantissa = _a[0], xToStringExponent = _a[1];
            var xToStringMantissaWithoutDecimalPoint = xToStringMantissa.replace('.', '');
            if (xToStringExponentIndex >= 0 &&
                xToStringMantissaWithoutDecimalPoint.length <= p) {
                e = +xToStringExponent;
                m =
                    xToStringMantissaWithoutDecimalPoint +
                        repeat('0', p - xToStringMantissaWithoutDecimalPoint.length);
                xFinal = x;
            }
            else {
                e = getMagnitude(x);
                var decimalPlaceOffset = e - p + 1;
                // n is the integer containing the required precision digits. To derive the formatted string,
                // we will adjust its decimal place in the logic below.
                var n = Math.round(adjustDecimalPlace(x, decimalPlaceOffset));
                // The rounding caused the change of magnitude, so we should increment `e` by 1.
                if (adjustDecimalPlace(n, p - 1) >= 10) {
                    e = e + 1;
                    // Divide n by 10 to swallow one precision.
                    n = Math.floor(n / 10);
                }
                m = n.toString();
                // Equivalent of n * 10 ** (e - p + 1)
                xFinal = adjustDecimalPlace(n, p - 1 - e);
            }
        }
        var int;
        if (e >= p - 1) {
            m = m + repeat('0', e - p + 1);
            int = e + 1;
        }
        else if (e >= 0) {
            m = m.slice(0, e + 1) + "." + m.slice(e + 1);
            int = e + 1;
        }
        else {
            m = "0." + repeat('0', -e - 1) + m;
            int = 1;
        }
        if (m.indexOf('.') >= 0 && maxPrecision > minPrecision) {
            var cut = maxPrecision - minPrecision;
            while (cut > 0 && m[m.length - 1] === '0') {
                m = m.slice(0, -1);
                cut--;
            }
            if (m[m.length - 1] === '.') {
                m = m.slice(0, -1);
            }
        }
        return { formattedString: m, roundedNumber: xFinal, integerDigitsCount: int };
        // x / (10 ** magnitude), but try to preserve as much floating point precision as possible.
        function adjustDecimalPlace(x, magnitude) {
            return magnitude < 0 ? x * Math.pow(10, -magnitude) : x / Math.pow(10, magnitude);
        }
    }

    /**
     * TODO: dedup with intl-pluralrules and support BigInt
     * https://tc39.es/ecma402/#sec-torawfixed
     * @param x a finite non-negative Number or BigInt
     * @param minFraction and integer between 0 and 20
     * @param maxFraction and integer between 0 and 20
     */
    function ToRawFixed(x, minFraction, maxFraction) {
        var f = maxFraction;
        var n = Math.round(x * Math.pow(10, f));
        var xFinal = n / Math.pow(10, f);
        // n is a positive integer, but it is possible to be greater than 1e21.
        // In such case we will go the slow path.
        // See also: https://tc39.es/ecma262/#sec-numeric-types-number-tostring
        var m;
        if (n < 1e21) {
            m = n.toString();
        }
        else {
            m = n.toString();
            var _a = m.split('e'), mantissa = _a[0], exponent = _a[1];
            m = mantissa.replace('.', '');
            m = m + repeat('0', Math.max(+exponent - m.length + 1, 0));
        }
        var int;
        if (f !== 0) {
            var k = m.length;
            if (k <= f) {
                var z = repeat('0', f + 1 - k);
                m = z + m;
                k = f + 1;
            }
            var a = m.slice(0, k - f);
            var b = m.slice(k - f);
            m = a + "." + b;
            int = a.length;
        }
        else {
            int = m.length;
        }
        var cut = maxFraction - minFraction;
        while (cut > 0 && m[m.length - 1] === '0') {
            m = m.slice(0, -1);
            cut--;
        }
        if (m[m.length - 1] === '.') {
            m = m.slice(0, -1);
        }
        return { formattedString: m, roundedNumber: xFinal, integerDigitsCount: int };
    }

    /**
     * https://tc39.es/ecma402/#sec-formatnumberstring
     */
    function FormatNumericToString(intlObject, x) {
        var isNegative = x < 0 || SameValue(x, -0);
        if (isNegative) {
            x = -x;
        }
        var result;
        var rourndingType = intlObject.roundingType;
        switch (rourndingType) {
            case 'significantDigits':
                result = ToRawPrecision(x, intlObject.minimumSignificantDigits, intlObject.maximumSignificantDigits);
                break;
            case 'fractionDigits':
                result = ToRawFixed(x, intlObject.minimumFractionDigits, intlObject.maximumFractionDigits);
                break;
            default:
                result = ToRawPrecision(x, 1, 2);
                if (result.integerDigitsCount > 1) {
                    result = ToRawFixed(x, 0, 0);
                }
                break;
        }
        x = result.roundedNumber;
        var string = result.formattedString;
        var int = result.integerDigitsCount;
        var minInteger = intlObject.minimumIntegerDigits;
        if (int < minInteger) {
            var forwardZeros = repeat('0', minInteger - int);
            string = forwardZeros + string;
        }
        if (isNegative) {
            x = -x;
        }
        return { roundedNumber: x, formattedString: string };
    }

    /**
     * https://tc39.es/ecma402/#sec-setnfdigitoptions
     */
    function SetNumberFormatDigitOptions(internalSlots, opts, mnfdDefault, mxfdDefault, notation) {
        var mnid = GetNumberOption(opts, 'minimumIntegerDigits', 1, 21, 1);
        var mnfd = opts.minimumFractionDigits;
        var mxfd = opts.maximumFractionDigits;
        var mnsd = opts.minimumSignificantDigits;
        var mxsd = opts.maximumSignificantDigits;
        internalSlots.minimumIntegerDigits = mnid;
        if (mnsd !== undefined || mxsd !== undefined) {
            internalSlots.roundingType = 'significantDigits';
            mnsd = DefaultNumberOption(mnsd, 1, 21, 1);
            mxsd = DefaultNumberOption(mxsd, mnsd, 21, 21);
            internalSlots.minimumSignificantDigits = mnsd;
            internalSlots.maximumSignificantDigits = mxsd;
        }
        else if (mnfd !== undefined || mxfd !== undefined) {
            internalSlots.roundingType = 'fractionDigits';
            mnfd = DefaultNumberOption(mnfd, 0, 20, mnfdDefault);
            var mxfdActualDefault = Math.max(mnfd, mxfdDefault);
            mxfd = DefaultNumberOption(mxfd, mnfd, 20, mxfdActualDefault);
            internalSlots.minimumFractionDigits = mnfd;
            internalSlots.maximumFractionDigits = mxfd;
        }
        else if (notation === 'compact') {
            internalSlots.roundingType = 'compactRounding';
        }
        else {
            internalSlots.roundingType = 'fractionDigits';
            internalSlots.minimumFractionDigits = mnfdDefault;
            internalSlots.maximumFractionDigits = mxfdDefault;
        }
    }

    /**
     * https://tc39.es/ecma402/#sec-bestavailablelocale
     * @param availableLocales
     * @param locale
     */
    function BestAvailableLocale(availableLocales, locale) {
        var candidate = locale;
        while (true) {
            if (~availableLocales.indexOf(candidate)) {
                return candidate;
            }
            var pos = candidate.lastIndexOf('-');
            if (!~pos) {
                return undefined;
            }
            if (pos >= 2 && candidate[pos - 2] === '-') {
                pos -= 2;
            }
            candidate = candidate.slice(0, pos);
        }
    }

    /**
     * https://tc39.es/ecma402/#sec-lookupmatcher
     * @param availableLocales
     * @param requestedLocales
     * @param getDefaultLocale
     */
    function LookupMatcher(availableLocales, requestedLocales, getDefaultLocale) {
        var result = { locale: '' };
        for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
            var locale = requestedLocales_1[_i];
            var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
            var availableLocale = BestAvailableLocale(availableLocales, noExtensionLocale);
            if (availableLocale) {
                result.locale = availableLocale;
                if (locale !== noExtensionLocale) {
                    result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);
                }
                return result;
            }
        }
        result.locale = getDefaultLocale();
        return result;
    }

    /**
     * https://tc39.es/ecma402/#sec-bestfitmatcher
     * @param availableLocales
     * @param requestedLocales
     * @param getDefaultLocale
     */
    function BestFitMatcher(availableLocales, requestedLocales, getDefaultLocale) {
        var result = { locale: '' };
        for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
            var locale = requestedLocales_1[_i];
            var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
            var availableLocale = BestAvailableLocale(availableLocales, noExtensionLocale);
            if (availableLocale) {
                result.locale = availableLocale;
                if (locale !== noExtensionLocale) {
                    result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);
                }
                return result;
            }
        }
        result.locale = getDefaultLocale();
        return result;
    }

    /**
     * https://tc39.es/ecma402/#sec-unicodeextensionvalue
     * @param extension
     * @param key
     */
    function UnicodeExtensionValue(extension, key) {
        invariant(key.length === 2, 'key must have 2 elements');
        var size = extension.length;
        var searchValue = "-" + key + "-";
        var pos = extension.indexOf(searchValue);
        if (pos !== -1) {
            var start = pos + 4;
            var end = start;
            var k = start;
            var done = false;
            while (!done) {
                var e = extension.indexOf('-', k);
                var len = void 0;
                if (e === -1) {
                    len = size - k;
                }
                else {
                    len = e - k;
                }
                if (len === 2) {
                    done = true;
                }
                else if (e === -1) {
                    end = size;
                    done = true;
                }
                else {
                    end = e;
                    k = e + 1;
                }
            }
            return extension.slice(start, end);
        }
        searchValue = "-" + key;
        pos = extension.indexOf(searchValue);
        if (pos !== -1 && pos + 3 === size) {
            return '';
        }
        return undefined;
    }

    /**
     * https://tc39.es/ecma402/#sec-resolvelocale
     */
    function ResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData, getDefaultLocale) {
        var matcher = options.localeMatcher;
        var r;
        if (matcher === 'lookup') {
            r = LookupMatcher(availableLocales, requestedLocales, getDefaultLocale);
        }
        else {
            r = BestFitMatcher(availableLocales, requestedLocales, getDefaultLocale);
        }
        var foundLocale = r.locale;
        var result = { locale: '', dataLocale: foundLocale };
        var supportedExtension = '-u';
        for (var _i = 0, relevantExtensionKeys_1 = relevantExtensionKeys; _i < relevantExtensionKeys_1.length; _i++) {
            var key = relevantExtensionKeys_1[_i];
            var foundLocaleData = localeData[foundLocale];
            invariant(typeof foundLocaleData === 'object' && foundLocaleData !== null, "locale data " + key + " must be an object");
            var keyLocaleData = foundLocaleData[key];
            invariant(Array.isArray(keyLocaleData), "keyLocaleData for " + key + " must be an array");
            var value = keyLocaleData[0];
            invariant(typeof value === 'string' || value === null, "value must be string or null but got " + typeof value + " in key " + key);
            var supportedExtensionAddition = '';
            if (r.extension) {
                var requestedValue = UnicodeExtensionValue(r.extension, key);
                if (requestedValue !== undefined) {
                    if (requestedValue !== '') {
                        if (~keyLocaleData.indexOf(requestedValue)) {
                            value = requestedValue;
                            supportedExtensionAddition = "-" + key + "-" + value;
                        }
                    }
                    else if (~requestedValue.indexOf('true')) {
                        value = 'true';
                        supportedExtensionAddition = "-" + key;
                    }
                }
            }
            if (key in options) {
                var optionsValue = options[key];
                invariant(typeof optionsValue === 'string' ||
                    typeof optionsValue === 'undefined' ||
                    optionsValue === null, 'optionsValue must be String, Undefined or Null');
                if (~keyLocaleData.indexOf(optionsValue)) {
                    if (optionsValue !== value) {
                        value = optionsValue;
                        supportedExtensionAddition = '';
                    }
                }
            }
            result[key] = value;
            supportedExtension += supportedExtensionAddition;
        }
        if (supportedExtension.length > 2) {
            var privateIndex = foundLocale.indexOf('-x-');
            if (privateIndex === -1) {
                foundLocale = foundLocale + supportedExtension;
            }
            else {
                var preExtension = foundLocale.slice(0, privateIndex);
                var postExtension = foundLocale.slice(privateIndex, foundLocale.length);
                foundLocale = preExtension + supportedExtension + postExtension;
            }
            foundLocale = Intl.getCanonicalLocales(foundLocale)[0];
        }
        result.locale = foundLocale;
        return result;
    }

    var $TypeError$2 = GetIntrinsic('%TypeError%');

    // http://www.ecma-international.org/ecma-262/5.1/#sec-9.10

    var CheckObjectCoercible = function CheckObjectCoercible(value, optMessage) {
    	if (value == null) {
    		throw new $TypeError$2(optMessage || ('Cannot call method on ' + value));
    	}
    	return value;
    };

    var RequireObjectCoercible = CheckObjectCoercible;

    var $Object = GetIntrinsic('%Object%');



    // https://www.ecma-international.org/ecma-262/6.0/#sec-toobject

    var ToObject = function ToObject(value) {
    	RequireObjectCoercible(value);
    	return $Object(value);
    };

    /**
     * https://tc39.es/ecma402/#sec-lookupsupportedlocales
     * @param availableLocales
     * @param requestedLocales
     */
    function LookupSupportedLocales(availableLocales, requestedLocales) {
        var subset = [];
        for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
            var locale = requestedLocales_1[_i];
            var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
            var availableLocale = BestAvailableLocale(availableLocales, noExtensionLocale);
            if (availableLocale) {
                subset.push(availableLocale);
            }
        }
        return subset;
    }

    /**
     * https://tc39.es/ecma402/#sec-supportedlocales
     * @param availableLocales
     * @param requestedLocales
     * @param options
     */
    function SupportedLocales(availableLocales, requestedLocales, options) {
        var matcher = 'best fit';
        if (options !== undefined) {
            options = ToObject(options);
            matcher = GetOption(options, 'localeMatcher', 'string', ['lookup', 'best fit'], 'best fit');
        }
        if (matcher === 'best fit') {
            return LookupSupportedLocales(availableLocales, requestedLocales);
        }
        return LookupSupportedLocales(availableLocales, requestedLocales);
    }

    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign = (undefined && undefined.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function getLocaleHierarchy(locale) {
        var results = [locale];
        var localeParts = locale.split('-');
        for (var i = localeParts.length; i > 1; i--) {
            results.push(localeParts.slice(0, i - 1).join('-'));
        }
        return results;
    }
    var MissingLocaleDataError = /** @class */ (function (_super) {
        __extends(MissingLocaleDataError, _super);
        function MissingLocaleDataError() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'MISSING_LOCALE_DATA';
            return _this;
        }
        return MissingLocaleDataError;
    }(Error));
    function unpackData(locale, localeData, 
    /** By default shallow merge the dictionaries. */
    reducer) {
        if (reducer === void 0) { reducer = function (all, d) { return (__assign(__assign({}, all), d)); }; }
        var localeHierarchy = getLocaleHierarchy(locale);
        var dataToMerge = localeHierarchy
            .map(function (l) { return localeData.data[l]; })
            .filter(Boolean);
        if (!dataToMerge.length) {
            throw new MissingLocaleDataError("Missing locale data for \"" + locale + "\", lookup hierarchy: " + localeHierarchy.join(', '));
        }
        dataToMerge.reverse();
        return dataToMerge.reduce(reducer, {});
    }

    var ADP = 0;
    var AFN = 0;
    var ALL = 0;
    var AMD = 2;
    var BHD = 3;
    var BIF = 0;
    var BYN = 2;
    var BYR = 0;
    var CAD = 2;
    var CHF = 2;
    var CLF = 4;
    var CLP = 0;
    var COP = 2;
    var CRC = 2;
    var CZK = 2;
    var DEFAULT = 2;
    var DJF = 0;
    var DKK = 2;
    var ESP = 0;
    var GNF = 0;
    var GYD = 2;
    var HUF = 2;
    var IDR = 2;
    var IQD = 0;
    var IRR = 0;
    var ISK = 0;
    var ITL = 0;
    var JOD = 3;
    var JPY = 0;
    var KMF = 0;
    var KPW = 0;
    var KRW = 0;
    var KWD = 3;
    var LAK = 0;
    var LBP = 0;
    var LUF = 0;
    var LYD = 3;
    var MGA = 0;
    var MGF = 0;
    var MMK = 0;
    var MNT = 2;
    var MRO = 0;
    var MUR = 2;
    var NOK = 2;
    var OMR = 3;
    var PKR = 2;
    var PYG = 0;
    var RSD = 0;
    var RWF = 0;
    var SEK = 2;
    var SLL = 0;
    var SOS = 0;
    var STD = 0;
    var SYP = 0;
    var TMM = 0;
    var TND = 3;
    var TRL = 0;
    var TWD = 2;
    var TZS = 2;
    var UGX = 0;
    var UYI = 0;
    var UYW = 4;
    var UZS = 2;
    var VEF = 2;
    var VND = 0;
    var VUV = 0;
    var XAF = 0;
    var XOF = 0;
    var XPF = 0;
    var YER = 0;
    var ZMK = 0;
    var ZWD = 0;
    var currencyDigits = {
    	ADP: ADP,
    	AFN: AFN,
    	ALL: ALL,
    	AMD: AMD,
    	BHD: BHD,
    	BIF: BIF,
    	BYN: BYN,
    	BYR: BYR,
    	CAD: CAD,
    	CHF: CHF,
    	CLF: CLF,
    	CLP: CLP,
    	COP: COP,
    	CRC: CRC,
    	CZK: CZK,
    	DEFAULT: DEFAULT,
    	DJF: DJF,
    	DKK: DKK,
    	ESP: ESP,
    	GNF: GNF,
    	GYD: GYD,
    	HUF: HUF,
    	IDR: IDR,
    	IQD: IQD,
    	IRR: IRR,
    	ISK: ISK,
    	ITL: ITL,
    	JOD: JOD,
    	JPY: JPY,
    	KMF: KMF,
    	KPW: KPW,
    	KRW: KRW,
    	KWD: KWD,
    	LAK: LAK,
    	LBP: LBP,
    	LUF: LUF,
    	LYD: LYD,
    	MGA: MGA,
    	MGF: MGF,
    	MMK: MMK,
    	MNT: MNT,
    	MRO: MRO,
    	MUR: MUR,
    	NOK: NOK,
    	OMR: OMR,
    	PKR: PKR,
    	PYG: PYG,
    	RSD: RSD,
    	RWF: RWF,
    	SEK: SEK,
    	SLL: SLL,
    	SOS: SOS,
    	STD: STD,
    	SYP: SYP,
    	TMM: TMM,
    	TND: TND,
    	TRL: TRL,
    	TWD: TWD,
    	TZS: TZS,
    	UGX: UGX,
    	UYI: UYI,
    	UYW: UYW,
    	UZS: UZS,
    	VEF: VEF,
    	VND: VND,
    	VUV: VUV,
    	XAF: XAF,
    	XOF: XOF,
    	XPF: XPF,
    	YER: YER,
    	ZMK: ZMK,
    	ZWD: ZWD
    };

    var currencyDigitsData = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ADP: ADP,
        AFN: AFN,
        ALL: ALL,
        AMD: AMD,
        BHD: BHD,
        BIF: BIF,
        BYN: BYN,
        BYR: BYR,
        CAD: CAD,
        CHF: CHF,
        CLF: CLF,
        CLP: CLP,
        COP: COP,
        CRC: CRC,
        CZK: CZK,
        DEFAULT: DEFAULT,
        DJF: DJF,
        DKK: DKK,
        ESP: ESP,
        GNF: GNF,
        GYD: GYD,
        HUF: HUF,
        IDR: IDR,
        IQD: IQD,
        IRR: IRR,
        ISK: ISK,
        ITL: ITL,
        JOD: JOD,
        JPY: JPY,
        KMF: KMF,
        KPW: KPW,
        KRW: KRW,
        KWD: KWD,
        LAK: LAK,
        LBP: LBP,
        LUF: LUF,
        LYD: LYD,
        MGA: MGA,
        MGF: MGF,
        MMK: MMK,
        MNT: MNT,
        MRO: MRO,
        MUR: MUR,
        NOK: NOK,
        OMR: OMR,
        PKR: PKR,
        PYG: PYG,
        RSD: RSD,
        RWF: RWF,
        SEK: SEK,
        SLL: SLL,
        SOS: SOS,
        STD: STD,
        SYP: SYP,
        TMM: TMM,
        TND: TND,
        TRL: TRL,
        TWD: TWD,
        TZS: TZS,
        UGX: UGX,
        UYI: UYI,
        UYW: UYW,
        UZS: UZS,
        VEF: VEF,
        VND: VND,
        VUV: VUV,
        XAF: XAF,
        XOF: XOF,
        XPF: XPF,
        YER: YER,
        ZMK: ZMK,
        ZWD: ZWD,
        'default': currencyDigits
    });

    var names = [
    	"adlm",
    	"ahom",
    	"arab",
    	"arabext",
    	"armn",
    	"armnlow",
    	"bali",
    	"beng",
    	"bhks",
    	"brah",
    	"cakm",
    	"cham",
    	"cyrl",
    	"deva",
    	"ethi",
    	"fullwide",
    	"geor",
    	"gong",
    	"gonm",
    	"grek",
    	"greklow",
    	"gujr",
    	"guru",
    	"hanidays",
    	"hanidec",
    	"hans",
    	"hansfin",
    	"hant",
    	"hantfin",
    	"hebr",
    	"hmng",
    	"hmnp",
    	"java",
    	"jpan",
    	"jpanfin",
    	"jpanyear",
    	"kali",
    	"khmr",
    	"knda",
    	"lana",
    	"lanatham",
    	"laoo",
    	"latn",
    	"lepc",
    	"limb",
    	"mathbold",
    	"mathdbl",
    	"mathmono",
    	"mathsanb",
    	"mathsans",
    	"mlym",
    	"modi",
    	"mong",
    	"mroo",
    	"mtei",
    	"mymr",
    	"mymrshan",
    	"mymrtlng",
    	"newa",
    	"nkoo",
    	"olck",
    	"orya",
    	"osma",
    	"rohg",
    	"roman",
    	"romanlow",
    	"saur",
    	"shrd",
    	"sind",
    	"sinh",
    	"sora",
    	"sund",
    	"takr",
    	"talu",
    	"taml",
    	"tamldec",
    	"telu",
    	"thai",
    	"tibt",
    	"tirh",
    	"vaii",
    	"wara",
    	"wcho"
    ];

    var adlm = [
    	"û•ê",
    	"û•ë",
    	"û•í",
    	"û•ì",
    	"û•î",
    	"û•ï",
    	"û•ñ",
    	"û•ó",
    	"û•ò",
    	"û•ô"
    ];
    var ahom = [
    	"ëú∞",
    	"ëú±",
    	"ëú≤",
    	"ëú≥",
    	"ëú¥",
    	"ëúµ",
    	"ëú∂",
    	"ëú∑",
    	"ëú∏",
    	"ëúπ"
    ];
    var arab = [
    	"Ÿ†",
    	"Ÿ°",
    	"Ÿ¢",
    	"Ÿ£",
    	"Ÿ§",
    	"Ÿ•",
    	"Ÿ¶",
    	"Ÿß",
    	"Ÿ®",
    	"Ÿ©"
    ];
    var arabext = [
    	"€∞",
    	"€±",
    	"€≤",
    	"€≥",
    	"€¥",
    	"€µ",
    	"€∂",
    	"€∑",
    	"€∏",
    	"€π"
    ];
    var bali = [
    	"·≠ê",
    	"·≠ë",
    	"·≠í",
    	"·≠ì",
    	"·≠î",
    	"·≠ï",
    	"·≠ñ",
    	"·≠ó",
    	"·≠ò",
    	"·≠ô"
    ];
    var beng = [
    	"‡ß¶",
    	"‡ßß",
    	"‡ß®",
    	"‡ß©",
    	"‡ß™",
    	"‡ß´",
    	"‡ß¨",
    	"‡ß≠",
    	"‡ßÆ",
    	"‡ßØ"
    ];
    var bhks = [
    	"ë±ê",
    	"ë±ë",
    	"ë±í",
    	"ë±ì",
    	"ë±î",
    	"ë±ï",
    	"ë±ñ",
    	"ë±ó",
    	"ë±ò",
    	"ë±ô"
    ];
    var brah = [
    	"ëÅ¶",
    	"ëÅß",
    	"ëÅ®",
    	"ëÅ©",
    	"ëÅ™",
    	"ëÅ´",
    	"ëÅ¨",
    	"ëÅ≠",
    	"ëÅÆ",
    	"ëÅØ"
    ];
    var cakm = [
    	"ëÑ∂",
    	"ëÑ∑",
    	"ëÑ∏",
    	"ëÑπ",
    	"ëÑ∫",
    	"ëÑª",
    	"ëÑº",
    	"ëÑΩ",
    	"ëÑæ",
    	"ëÑø"
    ];
    var cham = [
    	"Í©ê",
    	"Í©ë",
    	"Í©í",
    	"Í©ì",
    	"Í©î",
    	"Í©ï",
    	"Í©ñ",
    	"Í©ó",
    	"Í©ò",
    	"Í©ô"
    ];
    var deva = [
    	"‡•¶",
    	"‡•ß",
    	"‡•®",
    	"‡•©",
    	"‡•™",
    	"‡•´",
    	"‡•¨",
    	"‡•≠",
    	"‡•Æ",
    	"‡•Ø"
    ];
    var diak = [
    	"ë•ê",
    	"ë•ë",
    	"ë•í",
    	"ë•ì",
    	"ë•î",
    	"ë•ï",
    	"ë•ñ",
    	"ë•ó",
    	"ë•ò",
    	"ë•ô"
    ];
    var fullwide = [
    	"Ôºê",
    	"Ôºë",
    	"Ôºí",
    	"Ôºì",
    	"Ôºî",
    	"Ôºï",
    	"Ôºñ",
    	"Ôºó",
    	"Ôºò",
    	"Ôºô"
    ];
    var gong = [
    	"ë∂†",
    	"ë∂°",
    	"ë∂¢",
    	"ë∂£",
    	"ë∂§",
    	"ë∂•",
    	"ë∂¶",
    	"ë∂ß",
    	"ë∂®",
    	"ë∂©"
    ];
    var gonm = [
    	"ëµê",
    	"ëµë",
    	"ëµí",
    	"ëµì",
    	"ëµî",
    	"ëµï",
    	"ëµñ",
    	"ëµó",
    	"ëµò",
    	"ëµô"
    ];
    var gujr = [
    	"‡´¶",
    	"‡´ß",
    	"‡´®",
    	"‡´©",
    	"‡´™",
    	"‡´´",
    	"‡´¨",
    	"‡´≠",
    	"‡´Æ",
    	"‡´Ø"
    ];
    var guru = [
    	"‡©¶",
    	"‡©ß",
    	"‡©®",
    	"‡©©",
    	"‡©™",
    	"‡©´",
    	"‡©¨",
    	"‡©≠",
    	"‡©Æ",
    	"‡©Ø"
    ];
    var hanidec = [
    	"„Äá",
    	"‰∏Ä",
    	"‰∫å",
    	"‰∏â",
    	"Âõõ",
    	"‰∫î",
    	"ÂÖ≠",
    	"‰∏É",
    	"ÂÖ´",
    	"‰πù"
    ];
    var hmng = [
    	"ñ≠ê",
    	"ñ≠ë",
    	"ñ≠í",
    	"ñ≠ì",
    	"ñ≠î",
    	"ñ≠ï",
    	"ñ≠ñ",
    	"ñ≠ó",
    	"ñ≠ò",
    	"ñ≠ô"
    ];
    var hmnp = [
    	"ûÖÄ",
    	"ûÖÅ",
    	"ûÖÇ",
    	"ûÖÉ",
    	"ûÖÑ",
    	"ûÖÖ",
    	"ûÖÜ",
    	"ûÖá",
    	"ûÖà",
    	"ûÖâ"
    ];
    var java = [
    	"Íßê",
    	"Íßë",
    	"Íßí",
    	"Íßì",
    	"Íßî",
    	"Íßï",
    	"Íßñ",
    	"Íßó",
    	"Íßò",
    	"Íßô"
    ];
    var kali = [
    	"Í§Ä",
    	"Í§Å",
    	"Í§Ç",
    	"Í§É",
    	"Í§Ñ",
    	"Í§Ö",
    	"Í§Ü",
    	"Í§á",
    	"Í§à",
    	"Í§â"
    ];
    var khmr = [
    	"·ü†",
    	"·ü°",
    	"·ü¢",
    	"·ü£",
    	"·ü§",
    	"·ü•",
    	"·ü¶",
    	"·üß",
    	"·ü®",
    	"·ü©"
    ];
    var knda = [
    	"‡≥¶",
    	"‡≥ß",
    	"‡≥®",
    	"‡≥©",
    	"‡≥™",
    	"‡≥´",
    	"‡≥¨",
    	"‡≥≠",
    	"‡≥Æ",
    	"‡≥Ø"
    ];
    var lana = [
    	"·™Ä",
    	"·™Å",
    	"·™Ç",
    	"·™É",
    	"·™Ñ",
    	"·™Ö",
    	"·™Ü",
    	"·™á",
    	"·™à",
    	"·™â"
    ];
    var lanatham = [
    	"·™ê",
    	"·™ë",
    	"·™í",
    	"·™ì",
    	"·™î",
    	"·™ï",
    	"·™ñ",
    	"·™ó",
    	"·™ò",
    	"·™ô"
    ];
    var laoo = [
    	"‡ªê",
    	"‡ªë",
    	"‡ªí",
    	"‡ªì",
    	"‡ªî",
    	"‡ªï",
    	"‡ªñ",
    	"‡ªó",
    	"‡ªò",
    	"‡ªô"
    ];
    var lepc = [
    	"·™ê",
    	"·™ë",
    	"·™í",
    	"·™ì",
    	"·™î",
    	"·™ï",
    	"·™ñ",
    	"·™ó",
    	"·™ò",
    	"·™ô"
    ];
    var limb = [
    	"·•Ü",
    	"·•á",
    	"·•à",
    	"·•â",
    	"·•ä",
    	"·•ã",
    	"·•å",
    	"·•ç",
    	"·•é",
    	"·•è"
    ];
    var mathbold = [
    	"ùüé",
    	"ùüè",
    	"ùüê",
    	"ùüë",
    	"ùüí",
    	"ùüì",
    	"ùüî",
    	"ùüï",
    	"ùüñ",
    	"ùüó"
    ];
    var mathdbl = [
    	"ùüò",
    	"ùüô",
    	"ùüö",
    	"ùüõ",
    	"ùüú",
    	"ùüù",
    	"ùüû",
    	"ùüü",
    	"ùü†",
    	"ùü°"
    ];
    var mathmono = [
    	"ùü∂",
    	"ùü∑",
    	"ùü∏",
    	"ùüπ",
    	"ùü∫",
    	"ùüª",
    	"ùüº",
    	"ùüΩ",
    	"ùüæ",
    	"ùüø"
    ];
    var mathsanb = [
    	"ùü¨",
    	"ùü≠",
    	"ùüÆ",
    	"ùüØ",
    	"ùü∞",
    	"ùü±",
    	"ùü≤",
    	"ùü≥",
    	"ùü¥",
    	"ùüµ"
    ];
    var mathsans = [
    	"ùü¢",
    	"ùü£",
    	"ùü§",
    	"ùü•",
    	"ùü¶",
    	"ùüß",
    	"ùü®",
    	"ùü©",
    	"ùü™",
    	"ùü´"
    ];
    var mlym = [
    	"‡µ¶",
    	"‡µß",
    	"‡µ®",
    	"‡µ©",
    	"‡µ™",
    	"‡µ´",
    	"‡µ¨",
    	"‡µ≠",
    	"‡µÆ",
    	"‡µØ"
    ];
    var modi = [
    	"ëôê",
    	"ëôë",
    	"ëôí",
    	"ëôì",
    	"ëôî",
    	"ëôï",
    	"ëôñ",
    	"ëôó",
    	"ëôò",
    	"ëôô"
    ];
    var mong = [
    	"·†ê",
    	"·†ë",
    	"·†í",
    	"·†ì",
    	"·†î",
    	"·†ï",
    	"·†ñ",
    	"·†ó",
    	"·†ò",
    	"·†ô"
    ];
    var mroo = [
    	"ñ©†",
    	"ñ©°",
    	"ñ©¢",
    	"ñ©£",
    	"ñ©§",
    	"ñ©•",
    	"ñ©¶",
    	"ñ©ß",
    	"ñ©®",
    	"ñ©©"
    ];
    var mtei = [
    	"ÍØ∞",
    	"ÍØ±",
    	"ÍØ≤",
    	"ÍØ≥",
    	"ÍØ¥",
    	"ÍØµ",
    	"ÍØ∂",
    	"ÍØ∑",
    	"ÍØ∏",
    	"ÍØπ"
    ];
    var mymr = [
    	"·ÅÄ",
    	"·ÅÅ",
    	"·ÅÇ",
    	"·ÅÉ",
    	"·ÅÑ",
    	"·ÅÖ",
    	"·ÅÜ",
    	"·Åá",
    	"·Åà",
    	"·Åâ"
    ];
    var mymrshan = [
    	"·Çê",
    	"·Çë",
    	"·Çí",
    	"·Çì",
    	"·Çî",
    	"·Çï",
    	"·Çñ",
    	"·Çó",
    	"·Çò",
    	"·Çô"
    ];
    var mymrtlng = [
    	"Íß∞",
    	"Íß±",
    	"Íß≤",
    	"Íß≥",
    	"Íß¥",
    	"Íßµ",
    	"Íß∂",
    	"Íß∑",
    	"Íß∏",
    	"Íßπ"
    ];
    var newa = [
    	"ëëê",
    	"ëëë",
    	"ëëí",
    	"ëëì",
    	"ëëî",
    	"ëëï",
    	"ëëñ",
    	"ëëó",
    	"ëëò",
    	"ëëô"
    ];
    var nkoo = [
    	"ﬂÄ",
    	"ﬂÅ",
    	"ﬂÇ",
    	"ﬂÉ",
    	"ﬂÑ",
    	"ﬂÖ",
    	"ﬂÜ",
    	"ﬂá",
    	"ﬂà",
    	"ﬂâ"
    ];
    var olck = [
    	"·±ê",
    	"·±ë",
    	"·±í",
    	"·±ì",
    	"·±î",
    	"·±ï",
    	"·±ñ",
    	"·±ó",
    	"·±ò",
    	"·±ô"
    ];
    var orya = [
    	"‡≠¶",
    	"‡≠ß",
    	"‡≠®",
    	"‡≠©",
    	"‡≠™",
    	"‡≠´",
    	"‡≠¨",
    	"‡≠≠",
    	"‡≠Æ",
    	"‡≠Ø"
    ];
    var osma = [
    	"êí†",
    	"êí°",
    	"êí¢",
    	"êí£",
    	"êí§",
    	"êí•",
    	"êí¶",
    	"êíß",
    	"êí®",
    	"êí©"
    ];
    var rohg = [
    	"ê¥∞",
    	"ê¥±",
    	"ê¥≤",
    	"ê¥≥",
    	"ê¥¥",
    	"ê¥µ",
    	"ê¥∂",
    	"ê¥∑",
    	"ê¥∏",
    	"ê¥π"
    ];
    var saur = [
    	"Í£ê",
    	"Í£ë",
    	"Í£í",
    	"Í£ì",
    	"Í£î",
    	"Í£ï",
    	"Í£ñ",
    	"Í£ó",
    	"Í£ò",
    	"Í£ô"
    ];
    var segment = [
    	"üØ∞",
    	"üØ±",
    	"üØ≤",
    	"üØ≥",
    	"üØ¥",
    	"üØµ",
    	"üØ∂",
    	"üØ∑",
    	"üØ∏",
    	"üØπ"
    ];
    var shrd = [
    	"ëáê",
    	"ëáë",
    	"ëáí",
    	"ëáì",
    	"ëáî",
    	"ëáï",
    	"ëáñ",
    	"ëáó",
    	"ëáò",
    	"ëáô"
    ];
    var sind = [
    	"ëã∞",
    	"ëã±",
    	"ëã≤",
    	"ëã≥",
    	"ëã¥",
    	"ëãµ",
    	"ëã∂",
    	"ëã∑",
    	"ëã∏",
    	"ëãπ"
    ];
    var sinh = [
    	"‡∑¶",
    	"‡∑ß",
    	"‡∑®",
    	"‡∑©",
    	"‡∑™",
    	"‡∑´",
    	"‡∑¨",
    	"‡∑≠",
    	"‡∑Æ",
    	"‡∑Ø"
    ];
    var sora = [
    	"ëÉ∞",
    	"ëÉ±",
    	"ëÉ≤",
    	"ëÉ≥",
    	"ëÉ¥",
    	"ëÉµ",
    	"ëÉ∂",
    	"ëÉ∑",
    	"ëÉ∏",
    	"ëÉπ"
    ];
    var sund = [
    	"·Æ∞",
    	"·Æ±",
    	"·Æ≤",
    	"·Æ≥",
    	"·Æ¥",
    	"·Æµ",
    	"·Æ∂",
    	"·Æ∑",
    	"·Æ∏",
    	"·Æπ"
    ];
    var takr = [
    	"ëõÄ",
    	"ëõÅ",
    	"ëõÇ",
    	"ëõÉ",
    	"ëõÑ",
    	"ëõÖ",
    	"ëõÜ",
    	"ëõá",
    	"ëõà",
    	"ëõâ"
    ];
    var talu = [
    	"·ßê",
    	"·ßë",
    	"·ßí",
    	"·ßì",
    	"·ßî",
    	"·ßï",
    	"·ßñ",
    	"·ßó",
    	"·ßò",
    	"·ßô"
    ];
    var tamldec = [
    	"‡Ø¶",
    	"‡Øß",
    	"‡Ø®",
    	"‡Ø©",
    	"‡Ø™",
    	"‡Ø´",
    	"‡Ø¨",
    	"‡Ø≠",
    	"‡ØÆ",
    	"‡ØØ"
    ];
    var telu = [
    	"‡±¶",
    	"‡±ß",
    	"‡±®",
    	"‡±©",
    	"‡±™",
    	"‡±´",
    	"‡±¨",
    	"‡±≠",
    	"‡±Æ",
    	"‡±Ø"
    ];
    var thai = [
    	"‡πê",
    	"‡πë",
    	"‡πí",
    	"‡πì",
    	"‡πî",
    	"‡πï",
    	"‡πñ",
    	"‡πó",
    	"‡πò",
    	"‡πô"
    ];
    var tibt = [
    	"‡º†",
    	"‡º°",
    	"‡º¢",
    	"‡º£",
    	"‡º§",
    	"‡º•",
    	"‡º¶",
    	"‡ºß",
    	"‡º®",
    	"‡º©"
    ];
    var tirh = [
    	"ëìê",
    	"ëìë",
    	"ëìí",
    	"ëìì",
    	"ëìî",
    	"ëìï",
    	"ëìñ",
    	"ëìó",
    	"ëìò",
    	"ëìô"
    ];
    var vaii = [
    	"·ò†",
    	"·ò°",
    	"·ò¢",
    	"·ò£",
    	"·ò§",
    	"·ò•",
    	"·ò¶",
    	"·òß",
    	"·ò®",
    	"·ò©"
    ];
    var wara = [
    	"ë£†",
    	"ë£°",
    	"ë£¢",
    	"ë££",
    	"ë£§",
    	"ë£•",
    	"ë£¶",
    	"ë£ß",
    	"ë£®",
    	"ë£©"
    ];
    var wcho = [
    	"ûã∞",
    	"ûã±",
    	"ûã≤",
    	"ûã≥",
    	"ûã¥",
    	"ûãµ",
    	"ûã∂",
    	"ûã∑",
    	"ûã∏",
    	"ûãπ"
    ];
    var digitMapping = {
    	adlm: adlm,
    	ahom: ahom,
    	arab: arab,
    	arabext: arabext,
    	bali: bali,
    	beng: beng,
    	bhks: bhks,
    	brah: brah,
    	cakm: cakm,
    	cham: cham,
    	deva: deva,
    	diak: diak,
    	fullwide: fullwide,
    	gong: gong,
    	gonm: gonm,
    	gujr: gujr,
    	guru: guru,
    	hanidec: hanidec,
    	hmng: hmng,
    	hmnp: hmnp,
    	java: java,
    	kali: kali,
    	khmr: khmr,
    	knda: knda,
    	lana: lana,
    	lanatham: lanatham,
    	laoo: laoo,
    	lepc: lepc,
    	limb: limb,
    	mathbold: mathbold,
    	mathdbl: mathdbl,
    	mathmono: mathmono,
    	mathsanb: mathsanb,
    	mathsans: mathsans,
    	mlym: mlym,
    	modi: modi,
    	mong: mong,
    	mroo: mroo,
    	mtei: mtei,
    	mymr: mymr,
    	mymrshan: mymrshan,
    	mymrtlng: mymrtlng,
    	newa: newa,
    	nkoo: nkoo,
    	olck: olck,
    	orya: orya,
    	osma: osma,
    	rohg: rohg,
    	saur: saur,
    	segment: segment,
    	shrd: shrd,
    	sind: sind,
    	sinh: sinh,
    	sora: sora,
    	sund: sund,
    	takr: takr,
    	talu: talu,
    	tamldec: tamldec,
    	telu: telu,
    	thai: thai,
    	tibt: tibt,
    	tirh: tirh,
    	vaii: vaii,
    	wara: wara,
    	wcho: wcho
    };

    var digitMapping$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        adlm: adlm,
        ahom: ahom,
        arab: arab,
        arabext: arabext,
        bali: bali,
        beng: beng,
        bhks: bhks,
        brah: brah,
        cakm: cakm,
        cham: cham,
        deva: deva,
        diak: diak,
        fullwide: fullwide,
        gong: gong,
        gonm: gonm,
        gujr: gujr,
        guru: guru,
        hanidec: hanidec,
        hmng: hmng,
        hmnp: hmnp,
        java: java,
        kali: kali,
        khmr: khmr,
        knda: knda,
        lana: lana,
        lanatham: lanatham,
        laoo: laoo,
        lepc: lepc,
        limb: limb,
        mathbold: mathbold,
        mathdbl: mathdbl,
        mathmono: mathmono,
        mathsanb: mathsanb,
        mathsans: mathsans,
        mlym: mlym,
        modi: modi,
        mong: mong,
        mroo: mroo,
        mtei: mtei,
        mymr: mymr,
        mymrshan: mymrshan,
        mymrtlng: mymrtlng,
        newa: newa,
        nkoo: nkoo,
        olck: olck,
        orya: orya,
        osma: osma,
        rohg: rohg,
        saur: saur,
        segment: segment,
        shrd: shrd,
        sind: sind,
        sinh: sinh,
        sora: sora,
        sund: sund,
        takr: takr,
        talu: talu,
        tamldec: tamldec,
        telu: telu,
        thai: thai,
        tibt: tibt,
        tirh: tirh,
        vaii: vaii,
        wara: wara,
        wcho: wcho,
        'default': digitMapping
    });

    // This is from: unicode-12.1.0/General_Category/Symbol/regex.js
    // IE11 does not support unicode flag, otherwise this is just /\p{S}/u.
    var S_UNICODE_REGEX = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20BF\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B98-\u2BFF\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uFB29\uFBB2-\uFBC1\uFDFC\uFDFD\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD6C\uDD70-\uDDAC\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED5\uDEE0-\uDEEC\uDEF0-\uDEFA\uDF00-\uDF73\uDF80-\uDFD8\uDFE0-\uDFEB]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD00-\uDD0B\uDD0D-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDE53\uDE60-\uDE6D\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95]/;
    // /^\p{S}/u
    var CARET_S_UNICODE_REGEX = new RegExp("^" + S_UNICODE_REGEX.source);
    // /\p{S}$/u
    var S_DOLLAR_UNICODE_REGEX = new RegExp(S_UNICODE_REGEX.source + "$");
    var CLDR_NUMBER_PATTERN = /[#0](?:[\.,][#0]+)*/g;
    function formatToParts(numberResult, data, pl, options) {
        var sign = numberResult.sign, exponent = numberResult.exponent, magnitude = numberResult.magnitude;
        var notation = options.notation, style = options.style, numberingSystem = options.numberingSystem;
        var defaultNumberingSystem = data.numbers.nu[0];
        // #region Part 1: partition and interpolate the CLDR number pattern.
        // ----------------------------------------------------------
        var compactNumberPattern = null;
        if (notation === 'compact' && magnitude) {
            compactNumberPattern = getCompactDisplayPattern(numberResult, pl, data, style, options.compactDisplay, options.currencyDisplay, numberingSystem);
        }
        // This is used multiple times
        var nonNameCurrencyPart;
        if (style === 'currency' && options.currencyDisplay !== 'name') {
            var byCurrencyDisplay = data.currencies[options.currency];
            if (byCurrencyDisplay) {
                switch (options.currencyDisplay) {
                    case 'code':
                        nonNameCurrencyPart = options.currency;
                        break;
                    case 'symbol':
                        nonNameCurrencyPart = byCurrencyDisplay.symbol;
                        break;
                    default:
                        nonNameCurrencyPart = byCurrencyDisplay.narrow;
                        break;
                }
            }
            else {
                // Fallback for unknown currency
                nonNameCurrencyPart = options.currency;
            }
        }
        var numberPattern;
        if (!compactNumberPattern) {
            // Note: if the style is unit, or is currency and the currency display is name,
            // its unit parts will be interpolated in part 2. So here we can fallback to decimal.
            if (style === 'decimal' ||
                style === 'unit' ||
                (style === 'currency' && options.currencyDisplay === 'name')) {
                // Shortcut for decimal
                var decimalData = data.numbers.decimal[numberingSystem] ||
                    data.numbers.decimal[defaultNumberingSystem];
                numberPattern = getPatternForSign(decimalData.standard, sign);
            }
            else if (style === 'currency') {
                var currencyData = data.numbers.currency[numberingSystem] ||
                    data.numbers.currency[defaultNumberingSystem];
                // We replace number pattern part with `0` for easier postprocessing.
                numberPattern = getPatternForSign(currencyData[options.currencySign], sign);
            }
            else {
                // percent
                var percentPattern = data.numbers.percent[numberingSystem] ||
                    data.numbers.percent[defaultNumberingSystem];
                numberPattern = getPatternForSign(percentPattern, sign);
            }
        }
        else {
            numberPattern = compactNumberPattern;
        }
        // Extract the decimal number pattern string. It looks like "#,##0,00", which will later be
        // used to infer decimal group sizes.
        var decimalNumberPattern = CLDR_NUMBER_PATTERN.exec(numberPattern)[0];
        // Now we start to substitute patterns
        // 1. replace strings like `0` and `#,##0.00` with `{0}`
        // 2. unquote characters (invariant: the quoted characters does not contain the special tokens)
        numberPattern = numberPattern
            .replace(CLDR_NUMBER_PATTERN, '{0}')
            .replace(/'(.)'/g, '$1');
        // Handle currency spacing (both compact and non-compact).
        if (style === 'currency' && options.currencyDisplay !== 'name') {
            var currencyData = data.numbers.currency[numberingSystem] ||
                data.numbers.currency[defaultNumberingSystem];
            // See `currencySpacing` substitution rule in TR-35.
            // Here we always assume the currencyMatch is "[:^S:]" and surroundingMatch is "[:digit:]".
            //
            // Example 1: for pattern "#,##0.00¬§" with symbol "US$", we replace "¬§" with the symbol,
            // but insert an extra non-break space before the symbol, because "[:^S:]" matches "U" in
            // "US$" and "[:digit:]" matches the latn numbering system digits.
            //
            // Example 2: for pattern "¬§#,##0.00" with symbol "US$", there is no spacing between symbol
            // and number, because `$` does not match "[:^S:]".
            //
            // Implementation note: here we do the best effort to infer the insertion.
            // We also assume that `beforeInsertBetween` and `afterInsertBetween` will never be `;`.
            var afterCurrency = currencyData.currencySpacing.afterInsertBetween;
            if (afterCurrency && !S_DOLLAR_UNICODE_REGEX.test(nonNameCurrencyPart)) {
                numberPattern = numberPattern.replace('¬§{0}', "\u00A4" + afterCurrency + "{0}");
            }
            var beforeCurrency = currencyData.currencySpacing.beforeInsertBetween;
            if (beforeCurrency && !CARET_S_UNICODE_REGEX.test(nonNameCurrencyPart)) {
                numberPattern = numberPattern.replace('{0}¬§', "{0}" + beforeCurrency + "\u00A4");
            }
        }
        // The following tokens are special: `{0}`, `¬§`, `%`, `-`, `+`, `{c:...}.
        var numberPatternParts = numberPattern.split(/({c:[^}]+}|\{0\}|[¬§%\-\+])/g);
        var numberParts = [];
        var symbols = data.numbers.symbols[numberingSystem] ||
            data.numbers.symbols[defaultNumberingSystem];
        for (var _i = 0, numberPatternParts_1 = numberPatternParts; _i < numberPatternParts_1.length; _i++) {
            var part = numberPatternParts_1[_i];
            if (!part) {
                continue;
            }
            switch (part) {
                case '{0}': {
                    // We only need to handle scientific and engineering notation here.
                    numberParts.push.apply(numberParts, paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, 
                    // If compact number pattern exists, do not insert group separators.
                    !compactNumberPattern && options.useGrouping, decimalNumberPattern));
                    break;
                }
                case '-':
                    numberParts.push({ type: 'minusSign', value: symbols.minusSign });
                    break;
                case '+':
                    numberParts.push({ type: 'plusSign', value: symbols.plusSign });
                    break;
                case '%':
                    numberParts.push({ type: 'percentSign', value: symbols.percentSign });
                    break;
                case '¬§':
                    // Computed above when handling currency spacing.
                    numberParts.push({ type: 'currency', value: nonNameCurrencyPart });
                    break;
                default:
                    if (/^\{c:/.test(part)) {
                        numberParts.push({
                            type: 'compact',
                            value: part.substring(3, part.length - 1),
                        });
                    }
                    else {
                        // literal
                        numberParts.push({ type: 'literal', value: part });
                    }
                    break;
            }
        }
        // #endregion
        // #region Part 2: interpolate unit pattern if necessary.
        // ----------------------------------------------
        switch (style) {
            case 'currency': {
                // `currencyDisplay: 'name'` has similar pattern handling as units.
                if (options.currencyDisplay === 'name') {
                    var unitPattern = (data.numbers.currency[numberingSystem] ||
                        data.numbers.currency[defaultNumberingSystem]).unitPattern;
                    // Select plural
                    var unitName = void 0;
                    var currencyNameData = data.currencies[options.currency];
                    if (currencyNameData) {
                        unitName = selectPlural(pl, 
                        // NOTE: Google Chrome's Intl.NumberFormat uses the original number to determine the plurality,
                        // but the mantissa for unit. We think this is a bug in ICU, but will still replicate the behavior.
                        // TODO: use original number.
                        numberResult.roundedNumber * Math.pow(10, exponent), currencyNameData.displayName);
                    }
                    else {
                        // Fallback for unknown currency
                        unitName = options.currency;
                    }
                    // Do {0} and {1} substitution
                    var unitPatternParts = unitPattern.split(/(\{[01]\})/g);
                    var result = [];
                    for (var _a = 0, unitPatternParts_1 = unitPatternParts; _a < unitPatternParts_1.length; _a++) {
                        var part = unitPatternParts_1[_a];
                        switch (part) {
                            case '{0}':
                                result.push.apply(result, numberParts);
                                break;
                            case '{1}':
                                result.push({ type: 'currency', value: unitName });
                                break;
                            default:
                                if (part) {
                                    result.push({ type: 'literal', value: part });
                                }
                                break;
                        }
                    }
                    return result;
                }
                else {
                    return numberParts;
                }
            }
            case 'unit': {
                var unit = options.unit, unitDisplay = options.unitDisplay;
                var unitData = data.units.simple[unit];
                var unitPattern = void 0;
                if (unitData) {
                    // Simple unit pattern
                    unitPattern = selectPlural(pl, numberResult.roundedNumber, data.units.simple[unit][unitDisplay]);
                }
                else {
                    // See: http://unicode.org/reports/tr35/tr35-general.html#perUnitPatterns
                    // If cannot find unit in the simple pattern, it must be "per" compound pattern.
                    // Implementation note: we are not following TR-35 here because we need to format to parts!
                    var _b = unit.split('-per-'), numeratorUnit = _b[0], denominatorUnit = _b[1];
                    unitData = data.units.simple[numeratorUnit];
                    var numeratorUnitPattern = selectPlural(pl, numberResult.roundedNumber, data.units.simple[numeratorUnit][unitDisplay]);
                    var perUnitPattern = data.units.simple[denominatorUnit].perUnit[unitDisplay];
                    if (perUnitPattern) {
                        // perUnitPattern exists, combine it with numeratorUnitPattern
                        unitPattern = perUnitPattern.replace('{0}', numeratorUnitPattern);
                    }
                    else {
                        // get compoundUnit pattern (e.g. "{0} per {1}"), repalce {0} with numerator pattern and {1} with
                        // the denominator pattern in singular form.
                        var perPattern = data.units.compound.per[unitDisplay];
                        var denominatorPattern = selectPlural(pl, 1, data.units.simple[denominatorUnit][unitDisplay]);
                        unitPattern = unitPattern = perPattern
                            .replace('{0}', numeratorUnitPattern)
                            .replace('{1}', denominatorPattern.replace('{0}', ''));
                    }
                }
                var result = [];
                // We need spacing around "{0}" because they are not treated as "unit" parts, but "literal".
                for (var _c = 0, _d = unitPattern.split(/(\s*\{0\}\s*)/); _c < _d.length; _c++) {
                    var part = _d[_c];
                    var interpolateMatch = /^(\s*)\{0\}(\s*)$/.exec(part);
                    if (interpolateMatch) {
                        // Space before "{0}"
                        if (interpolateMatch[1]) {
                            result.push({ type: 'literal', value: interpolateMatch[1] });
                        }
                        // "{0}" itself
                        result.push.apply(result, numberParts);
                        // Space after "{0}"
                        if (interpolateMatch[2]) {
                            result.push({ type: 'literal', value: interpolateMatch[2] });
                        }
                    }
                    else if (part) {
                        result.push({ type: 'unit', value: part });
                    }
                }
                return result;
            }
            default:
                return numberParts;
        }
        // #endregion
    }
    // A subset of https://tc39.es/ecma402/#sec-partitionnotationsubpattern
    // Plus the exponent parts handling.
    function paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, useGrouping, 
    /**
     * This is the decimal number pattern without signs or symbols.
     * It is used to infer the group size when `useGrouping` is true.
     *
     * A typical value looks like "#,##0.00" (primary group size is 3).
     * Some locales like Hindi has secondary group size of 2 (e.g. "#,##,##0.00").
     */
    decimalNumberPattern) {
        var result = [];
        // eslint-disable-next-line prefer-const
        var n = numberResult.formattedString, x = numberResult.roundedNumber;
        if (isNaN(x)) {
            return [{ type: 'nan', value: n }];
        }
        else if (!isFinite(x)) {
            return [{ type: 'infinity', value: n }];
        }
        var digitReplacementTable = digitMapping$1[numberingSystem];
        if (digitReplacementTable) {
            n = n.replace(/\d/g, function (digit) { return digitReplacementTable[+digit] || digit; });
        }
        // TODO: Else use an implementation dependent algorithm to map n to the appropriate
        // representation of n in the given numbering system.
        var decimalSepIndex = n.indexOf('.');
        var integer;
        var fraction;
        if (decimalSepIndex > 0) {
            integer = n.slice(0, decimalSepIndex);
            fraction = n.slice(decimalSepIndex + 1);
        }
        else {
            integer = n;
        }
        // #region Grouping integer digits
        // The weird compact and x >= 10000 check is to ensure consistency with Node.js and Chrome.
        // Note that `de` does not have compact form for thousands, but Node.js does not insert grouping separator
        // unless the rounded number is greater than 10000:
        //   NumberFormat('de', {notation: 'compact', compactDisplay: 'short'}).format(1234) //=> "1234"
        //   NumberFormat('de').format(1234) //=> "1.234"
        if (useGrouping && (notation !== 'compact' || x >= 10000)) {
            var groupSepSymbol = symbols.group;
            var groups = [];
            // > There may be two different grouping sizes: The primary grouping size used for the least
            // > significant integer group, and the secondary grouping size used for more significant groups.
            // > If a pattern contains multiple grouping separators, the interval between the last one and the
            // > end of the integer defines the primary grouping size, and the interval between the last two
            // > defines the secondary grouping size. All others are ignored.
            var integerNumberPattern = decimalNumberPattern.split('.')[0];
            var patternGroups = integerNumberPattern.split(',');
            var primaryGroupingSize = 3;
            var secondaryGroupingSize = 3;
            if (patternGroups.length > 1) {
                primaryGroupingSize = patternGroups[patternGroups.length - 1].length;
            }
            if (patternGroups.length > 2) {
                secondaryGroupingSize = patternGroups[patternGroups.length - 2].length;
            }
            var i = integer.length - primaryGroupingSize;
            if (i > 0) {
                // Slice the least significant integer group
                groups.push(integer.slice(i, i + primaryGroupingSize));
                // Then iteratively push the more signicant groups
                // TODO: handle surrogate pairs in some numbering system digits
                for (i -= secondaryGroupingSize; i > 0; i -= secondaryGroupingSize) {
                    groups.push(integer.slice(i, i + secondaryGroupingSize));
                }
                groups.push(integer.slice(0, i + secondaryGroupingSize));
            }
            else {
                groups.push(integer);
            }
            while (groups.length > 0) {
                var integerGroup = groups.pop();
                result.push({ type: 'integer', value: integerGroup });
                if (groups.length > 0) {
                    result.push({ type: 'group', value: groupSepSymbol });
                }
            }
        }
        else {
            result.push({ type: 'integer', value: integer });
        }
        // #endregion
        if (fraction !== undefined) {
            result.push({ type: 'decimal', value: symbols.decimal }, { type: 'fraction', value: fraction });
        }
        if ((notation === 'scientific' || notation === 'engineering') &&
            isFinite(x)) {
            result.push({ type: 'exponentSeparator', value: symbols.exponential });
            if (exponent < 0) {
                result.push({ type: 'exponentMinusSign', value: symbols.minusSign });
                exponent = -exponent;
            }
            var exponentResult = ToRawFixed(exponent, 0, 0);
            result.push({
                type: 'exponentInteger',
                value: exponentResult.formattedString,
            });
        }
        return result;
    }
    function getPatternForSign(pattern, sign) {
        if (pattern.indexOf(';') < 0) {
            pattern = pattern + ";-" + pattern;
        }
        var _a = pattern.split(';'), zeroPattern = _a[0], negativePattern = _a[1];
        switch (sign) {
            case 0:
                return zeroPattern;
            case -1:
                return negativePattern;
            default:
                return negativePattern.indexOf('-') >= 0
                    ? negativePattern.replace(/-/g, '+')
                    : "+" + zeroPattern;
        }
    }
    // Find the CLDR pattern for compact notation based on the magnitude of data and style.
    //
    // Example return value: "¬§¬†{c:laki}000;¬§{c:laki}¬†-0" (`sw` locale):
    // - Notice the `{c:...}` token that wraps the compact literal.
    // - The consecutive zeros are normalized to single zero to match CLDR_NUMBER_PATTERN.
    //
    // Returning null means the compact display pattern cannot be found.
    function getCompactDisplayPattern(numberResult, pl, data, style, compactDisplay, currencyDisplay, numberingSystem) {
        var _a;
        var roundedNumber = numberResult.roundedNumber, sign = numberResult.sign, magnitude = numberResult.magnitude;
        var magnitudeKey = String(Math.pow(10, magnitude));
        var defaultNumberingSystem = data.numbers.nu[0];
        var pattern;
        if (style === 'currency' && currencyDisplay !== 'name') {
            var byNumberingSystem = data.numbers.currency;
            var currencyData = byNumberingSystem[numberingSystem] ||
                byNumberingSystem[defaultNumberingSystem];
            // NOTE: compact notation ignores currencySign!
            var compactPluralRules = (_a = currencyData.short) === null || _a === void 0 ? void 0 : _a[magnitudeKey];
            if (!compactPluralRules) {
                return null;
            }
            pattern = selectPlural(pl, roundedNumber, compactPluralRules);
        }
        else {
            var byNumberingSystem = data.numbers.decimal;
            var byCompactDisplay = byNumberingSystem[numberingSystem] ||
                byNumberingSystem[defaultNumberingSystem];
            var compactPlaralRule = byCompactDisplay[compactDisplay][magnitudeKey];
            if (!compactPlaralRule) {
                return null;
            }
            pattern = selectPlural(pl, roundedNumber, compactPlaralRule);
        }
        // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats
        // > If the value is precisely ‚Äú0‚Äù, either explicit or defaulted, then the normal number format
        // > pattern for that sort of object is supplied.
        if (pattern === '0') {
            return null;
        }
        pattern = getPatternForSign(pattern, sign)
            // Extract compact literal from the pattern
            .replace(/([^\s;\-\+\d¬§]+)/g, '{c:$1}')
            // We replace one or more zeros with a single zero so it matches `CLDR_NUMBER_PATTERN`.
            .replace(/0+/, '0');
        return pattern;
    }
    function selectPlural(pl, x, rules) {
        return rules[pl.select(x)] || rules.other;
    }

    var internalSlotMap = new WeakMap();
    function getInternalSlots(x) {
        var internalSlots = internalSlotMap.get(x);
        if (!internalSlots) {
            internalSlots = Object.create(null);
            internalSlotMap.set(x, internalSlots);
        }
        return internalSlots;
    }

    // http://www.ecma-international.org/ecma-262/5.1/#sec-9.12

    var SameValue$1 = function SameValue(x, y) {
    	if (x === y) { // 0 === -0, but they are not identical.
    		if (x === 0) { return 1 / x === 1 / y; }
    		return true;
    	}
    	return _isNaN(x) && _isNaN(y);
    };

    var src = functionBind.call(Function.call, Object.prototype.hasOwnProperty);

    // https://www.ecma-international.org/ecma-262/6.0/#sec-ispropertykey

    var IsPropertyKey = function IsPropertyKey(argument) {
    	return typeof argument === 'string' || typeof argument === 'symbol';
    };

    // https://www.ecma-international.org/ecma-262/5.1/#sec-8

    var Type = function Type(x) {
    	if (x === null) {
    		return 'Null';
    	}
    	if (typeof x === 'undefined') {
    		return 'Undefined';
    	}
    	if (typeof x === 'function' || typeof x === 'object') {
    		return 'Object';
    	}
    	if (typeof x === 'number') {
    		return 'Number';
    	}
    	if (typeof x === 'boolean') {
    		return 'Boolean';
    	}
    	if (typeof x === 'string') {
    		return 'String';
    	}
    };

    // https://ecma-international.org/ecma-262/6.0/#sec-ecmascript-data-types-and-values

    var Type$1 = function Type$1(x) {
    	if (typeof x === 'symbol') {
    		return 'Symbol';
    	}
    	return Type(x);
    };

    var $TypeError$3 = GetIntrinsic('%TypeError%');






    // https://ecma-international.org/ecma-262/6.0/#sec-hasownproperty

    var HasOwnProperty = function HasOwnProperty(O, P) {
    	if (Type$1(O) !== 'Object') {
    		throw new $TypeError$3('Assertion failed: `O` must be an Object');
    	}
    	if (!IsPropertyKey(P)) {
    		throw new $TypeError$3('Assertion failed: `P` must be a Property Key');
    	}
    	return src(O, P);
    };

    var $apply = GetIntrinsic('%Function.prototype.apply%');
    var $call = GetIntrinsic('%Function.prototype.call%');
    var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || functionBind.call($call, $apply);

    var callBind = function callBind() {
    	return $reflectApply(functionBind, $call, arguments);
    };

    var apply = function applyBind() {
    	return $reflectApply(functionBind, $apply, arguments);
    };
    callBind.apply = apply;

    var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

    var callBound = function callBoundIntrinsic(name, allowMissing) {
    	var intrinsic = GetIntrinsic(name, !!allowMissing);
    	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.')) {
    		return callBind(intrinsic);
    	}
    	return intrinsic;
    };

    var $test = GetIntrinsic('RegExp.prototype.test');



    var regexTester = function regexTester(regex) {
    	return callBind($test, regex);
    };

    var isPrimitive = function isPrimitive(value) {
    	return value === null || (typeof value !== 'function' && typeof value !== 'object');
    };

    var isPrimitive$1 = function isPrimitive(value) {
    	return value === null || (typeof value !== 'function' && typeof value !== 'object');
    };

    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
    	try {
    		badArrayLike = Object.defineProperty({}, 'length', {
    			get: function () {
    				throw isCallableMarker;
    			}
    		});
    		isCallableMarker = {};
    	} catch (_) {
    		reflectApply = null;
    	}
    } else {
    	reflectApply = null;
    }

    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
    	try {
    		var fnStr = fnToStr.call(value);
    		return constructorRegex.test(fnStr);
    	} catch (e) {
    		return false; // not a function
    	}
    };

    var tryFunctionObject = function tryFunctionToStr(value) {
    	try {
    		if (isES6ClassFn(value)) { return false; }
    		fnToStr.call(value);
    		return true;
    	} catch (e) {
    		return false;
    	}
    };
    var toStr$1 = Object.prototype.toString;
    var fnClass = '[object Function]';
    var genClass = '[object GeneratorFunction]';
    var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

    var isCallable = reflectApply
    	? function isCallable(value) {
    		if (!value) { return false; }
    		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
    		if (typeof value === 'function' && !value.prototype) { return true; }
    		try {
    			reflectApply(value, null, badArrayLike);
    		} catch (e) {
    			if (e !== isCallableMarker) { return false; }
    		}
    		return !isES6ClassFn(value);
    	}
    	: function isCallable(value) {
    		if (!value) { return false; }
    		if (typeof value !== 'function' && typeof value !== 'object') { return false; }
    		if (typeof value === 'function' && !value.prototype) { return true; }
    		if (hasToStringTag) { return tryFunctionObject(value); }
    		if (isES6ClassFn(value)) { return false; }
    		var strClass = toStr$1.call(value);
    		return strClass === fnClass || strClass === genClass;
    	};

    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value) {
    	try {
    		getDay.call(value);
    		return true;
    	} catch (e) {
    		return false;
    	}
    };

    var toStr$2 = Object.prototype.toString;
    var dateClass = '[object Date]';
    var hasToStringTag$1 = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

    var isDateObject = function isDateObject(value) {
    	if (typeof value !== 'object' || value === null) {
    		return false;
    	}
    	return hasToStringTag$1 ? tryDateObject(value) : toStr$2.call(value) === dateClass;
    };

    var isSymbol = createCommonjsModule(function (module) {

    var toStr = Object.prototype.toString;
    var hasSymbols$1 = hasSymbols();

    if (hasSymbols$1) {
    	var symToStr = Symbol.prototype.toString;
    	var symStringRegex = /^Symbol\(.*\)$/;
    	var isSymbolObject = function isRealSymbolObject(value) {
    		if (typeof value.valueOf() !== 'symbol') {
    			return false;
    		}
    		return symStringRegex.test(symToStr.call(value));
    	};

    	module.exports = function isSymbol(value) {
    		if (typeof value === 'symbol') {
    			return true;
    		}
    		if (toStr.call(value) !== '[object Symbol]') {
    			return false;
    		}
    		try {
    			return isSymbolObject(value);
    		} catch (e) {
    			return false;
    		}
    	};
    } else {

    	module.exports = function isSymbol(value) {
    		// this environment does not support Symbols.
    		return false ;
    	};
    }
    });

    var hasSymbols$2 = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';






    var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
    	if (typeof O === 'undefined' || O === null) {
    		throw new TypeError('Cannot call method on ' + O);
    	}
    	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
    		throw new TypeError('hint must be "string" or "number"');
    	}
    	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
    	var method, result, i;
    	for (i = 0; i < methodNames.length; ++i) {
    		method = O[methodNames[i]];
    		if (isCallable(method)) {
    			result = method.call(O);
    			if (isPrimitive$1(result)) {
    				return result;
    			}
    		}
    	}
    	throw new TypeError('No default value');
    };

    var GetMethod = function GetMethod(O, P) {
    	var func = O[P];
    	if (func !== null && typeof func !== 'undefined') {
    		if (!isCallable(func)) {
    			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
    		}
    		return func;
    	}
    	return void 0;
    };

    // http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
    var es2015 = function ToPrimitive(input) {
    	if (isPrimitive$1(input)) {
    		return input;
    	}
    	var hint = 'default';
    	if (arguments.length > 1) {
    		if (arguments[1] === String) {
    			hint = 'string';
    		} else if (arguments[1] === Number) {
    			hint = 'number';
    		}
    	}

    	var exoticToPrim;
    	if (hasSymbols$2) {
    		if (Symbol.toPrimitive) {
    			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
    		} else if (isSymbol(input)) {
    			exoticToPrim = Symbol.prototype.valueOf;
    		}
    	}
    	if (typeof exoticToPrim !== 'undefined') {
    		var result = exoticToPrim.call(input, hint);
    		if (isPrimitive$1(result)) {
    			return result;
    		}
    		throw new TypeError('unable to convert exotic object to primitive');
    	}
    	if (hint === 'default' && (isDateObject(input) || isSymbol(input))) {
    		hint = 'string';
    	}
    	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
    };

    // https://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive

    var ToPrimitive = function ToPrimitive(input) {
    	if (arguments.length > 1) {
    		return es2015(input, arguments[1]);
    	}
    	return es2015(input);
    };

    var $TypeError$4 = GetIntrinsic('%TypeError%');
    var $Number = GetIntrinsic('%Number%');
    var $RegExp = GetIntrinsic('%RegExp%');
    var $parseInteger = GetIntrinsic('%parseInt%');





    var $strSlice = callBound('String.prototype.slice');
    var isBinary = regexTester(/^0b[01]+$/i);
    var isOctal = regexTester(/^0o[0-7]+$/i);
    var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
    var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
    var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
    var hasNonWS = regexTester(nonWSregex);

    // whitespace from: https://es5.github.io/#x15.5.4.20
    // implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
    var ws = [
    	'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
    	'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
    	'\u2029\uFEFF'
    ].join('');
    var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
    var $replace$1 = callBound('String.prototype.replace');
    var $trim = function (value) {
    	return $replace$1(value, trimRegex, '');
    };



    // https://www.ecma-international.org/ecma-262/6.0/#sec-tonumber

    var ToNumber = function ToNumber(argument) {
    	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
    	if (typeof value === 'symbol') {
    		throw new $TypeError$4('Cannot convert a Symbol value to a number');
    	}
    	if (typeof value === 'string') {
    		if (isBinary(value)) {
    			return ToNumber($parseInteger($strSlice(value, 2), 2));
    		} else if (isOctal(value)) {
    			return ToNumber($parseInteger($strSlice(value, 2), 8));
    		} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
    			return NaN;
    		} else {
    			var trimmed = $trim(value);
    			if (trimmed !== value) {
    				return ToNumber(trimmed);
    			}
    		}
    	}
    	return $Number(value);
    };

    var VALID_NUMBERING_SYSTEM_NAMES = new Set(names);
    var RESOLVED_OPTIONS_KEYS = [
        'locale',
        'numberingSystem',
        'style',
        'currency',
        'currencyDisplay',
        'currencySign',
        'unit',
        'unitDisplay',
        'minimumIntegerDigits',
        'minimumFractionDigits',
        'maximumFractionDigits',
        'minimumSignificantDigits',
        'maximumSignificantDigits',
        'useGrouping',
        'notation',
        'compactDisplay',
        'signDisplay',
    ];
    /**
     * Chop off the unicode extension from the locale string.
     */
    function removeUnicodeExtensionFromLocale(canonicalLocale) {
        var extensionIndex = canonicalLocale.indexOf('-u-');
        return extensionIndex >= 0
            ? canonicalLocale.slice(0, extensionIndex)
            : canonicalLocale;
    }
    /**
     * https://tc39.es/ecma402/#sec-currencydigits
     */
    function currencyDigits$1(c) {
        return HasOwnProperty(currencyDigitsData, c)
            ? currencyDigitsData[c]
            : 2;
    }
    /**
     * https://tc39.es/ecma402/#sec-initializenumberformat
     */
    function initializeNumberFormat(nf, locales, opts) {
        // @ts-ignore
        var requestedLocales = Intl.getCanonicalLocales(locales);
        var options = opts === undefined ? Object.create(null) : ToObject(opts);
        var opt = Object.create(null);
        var matcher = GetOption(options, 'localeMatcher', 'string', ['lookup', 'best fit'], 'best fit');
        opt.localeMatcher = matcher;
        var numberingSystem = GetOption(options, 'numberingSystem', 'string', undefined, undefined);
        if (numberingSystem !== undefined &&
            !VALID_NUMBERING_SYSTEM_NAMES.has(numberingSystem)) {
            // 8.a. If numberingSystem does not match the Unicode Locale Identifier type nonterminal,
            // throw a RangeError exception.
            throw RangeError("Invalid numberingSystems: " + numberingSystem);
        }
        opt.nu = numberingSystem;
        var localeData = NumberFormat.localeData;
        var r = ResolveLocale(NumberFormat.availableLocales, requestedLocales, opt, 
        // [[RelevantExtensionKeys]] slot, which is a constant
        ['nu'], localeData, NumberFormat.getDefaultLocale);
        var dataLocaleData = localeData[removeUnicodeExtensionFromLocale(r.locale)];
        var internalSlots = getInternalSlots(nf);
        internalSlots.locale = r.locale;
        internalSlots.dataLocale = r.dataLocale;
        internalSlots.numberingSystem = r.nu;
        internalSlots.dataLocaleData = dataLocaleData;
        setNumberFormatUnitOptions(nf, options);
        var style = internalSlots.style;
        var mnfdDefault;
        var mxfdDefault;
        if (style === 'currency') {
            var currency = internalSlots.currency;
            var cDigits = currencyDigits$1(currency);
            mnfdDefault = cDigits;
            mxfdDefault = cDigits;
        }
        else {
            mnfdDefault = 0;
            mxfdDefault = style === 'percent' ? 0 : 3;
        }
        var notation = GetOption(options, 'notation', 'string', ['standard', 'scientific', 'engineering', 'compact'], 'standard');
        internalSlots.notation = notation;
        SetNumberFormatDigitOptions(internalSlots, options, mnfdDefault, mxfdDefault, notation);
        var compactDisplay = GetOption(options, 'compactDisplay', 'string', ['short', 'long'], 'short');
        if (notation === 'compact') {
            internalSlots.compactDisplay = compactDisplay;
        }
        var useGrouping = GetOption(options, 'useGrouping', 'boolean', undefined, true);
        internalSlots.useGrouping = useGrouping;
        var signDisplay = GetOption(options, 'signDisplay', 'string', ['auto', 'never', 'always', 'exceptZero'], 'auto');
        internalSlots.signDisplay = signDisplay;
        return nf;
    }
    /**
     * https://tc39.es/ecma402/#sec-formatnumberstring
     */
    function partitionNumberPattern(numberFormat, x) {
        var _a;
        var internalSlots = getInternalSlots(numberFormat);
        var pl = internalSlots.pl, dataLocaleData = internalSlots.dataLocaleData, numberingSystem = internalSlots.numberingSystem;
        var symbols = dataLocaleData.numbers.symbols[numberingSystem] ||
            dataLocaleData.numbers.symbols[dataLocaleData.numbers.nu[0]];
        var magnitude = 0;
        var exponent = 0;
        var n;
        if (isNaN(x)) {
            n = symbols.nan;
        }
        else if (!isFinite(x)) {
            n = symbols.infinity;
        }
        else {
            if (internalSlots.style === 'percent') {
                x *= 100;
            }
            _a = computeExponent(numberFormat, x), exponent = _a[0], magnitude = _a[1];
            // Preserve more precision by doing multiplication when exponent is negative.
            x = exponent < 0 ? x * Math.pow(10, -exponent) : x / Math.pow(10, exponent);
            var formatNumberResult = FormatNumericToString(internalSlots, x);
            n = formatNumberResult.formattedString;
            x = formatNumberResult.roundedNumber;
        }
        // Based on https://tc39.es/ecma402/#sec-getnumberformatpattern
        // We need to do this before `x` is rounded.
        var sign;
        var signDisplay = internalSlots.signDisplay;
        switch (signDisplay) {
            case 'never':
                sign = 0;
                break;
            case 'auto':
                if (SameValue$1(x, 0) || x > 0 || isNaN(x)) {
                    sign = 0;
                }
                else {
                    sign = -1;
                }
                break;
            case 'always':
                if (SameValue$1(x, 0) || x > 0 || isNaN(x)) {
                    sign = 1;
                }
                else {
                    sign = -1;
                }
                break;
            default:
                // x === 0 -> x is 0 or x is -0
                if (x === 0 || isNaN(x)) {
                    sign = 0;
                }
                else if (x > 0) {
                    sign = 1;
                }
                else {
                    sign = -1;
                }
        }
        return formatToParts({ roundedNumber: x, formattedString: n, exponent: exponent, magnitude: magnitude, sign: sign }, internalSlots.dataLocaleData, pl, internalSlots);
    }
    function formatNumericToParts(numberFormat, x) {
        return partitionNumberPattern(numberFormat, x);
    }
    /**
     * https://tc39.es/ecma402/#sec-intl-numberformat-constructor
     */
    var NumberFormat = function (locales, options) {
        // Cannot use `new.target` bc of IE11 & TS transpiles it to something else
        if (!this || !(this instanceof NumberFormat)) {
            return new NumberFormat(locales, options);
        }
        initializeNumberFormat(this, locales, options);
        var internalSlots = getInternalSlots(this);
        var dataLocale = internalSlots.dataLocale;
        var dataLocaleData = NumberFormat.localeData[dataLocale];
        invariant(dataLocaleData !== undefined, "Cannot load locale-dependent data for " + dataLocale + ".");
        internalSlots.pl = new Intl.PluralRules(dataLocale, {
            minimumFractionDigits: internalSlots.minimumFractionDigits,
            maximumFractionDigits: internalSlots.maximumFractionDigits,
            minimumIntegerDigits: internalSlots.minimumIntegerDigits,
            minimumSignificantDigits: internalSlots.minimumSignificantDigits,
            maximumSignificantDigits: internalSlots.maximumSignificantDigits,
        });
    };
    defineProperty(NumberFormat.prototype, 'formatToParts', {
        value: function formatToParts(x) {
            return formatNumericToParts(this, toNumeric(x));
        },
    });
    defineProperty(NumberFormat.prototype, 'resolvedOptions', {
        value: function resolvedOptions() {
            if (typeof this !== 'object' || !(this instanceof NumberFormat)) {
                throw TypeError('Method Intl.NumberFormat.prototype.resolvedOptions called on incompatible receiver');
            }
            var internalSlots = getInternalSlots(this);
            var ro = {};
            for (var _i = 0, RESOLVED_OPTIONS_KEYS_1 = RESOLVED_OPTIONS_KEYS; _i < RESOLVED_OPTIONS_KEYS_1.length; _i++) {
                var key = RESOLVED_OPTIONS_KEYS_1[_i];
                var value = internalSlots[key];
                if (value !== undefined) {
                    ro[key] = value;
                }
            }
            return ro;
        },
    });
    var formatDescriptor = {
        enumerable: false,
        configurable: true,
        get: function () {
            if (typeof this !== 'object' || !(this instanceof NumberFormat)) {
                throw TypeError('Intl.NumberFormat format property accessor called on incompatible receiver');
            }
            var internalSlots = getInternalSlots(this);
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var numberFormat = this;
            var boundFormat = internalSlots.boundFormat;
            if (boundFormat === undefined) {
                // https://tc39.es/proposal-unified-intl-numberformat/section11/numberformat_diff_out.html#sec-number-format-functions
                boundFormat = function (value) {
                    // TODO: check bigint
                    var x = toNumeric(value);
                    return numberFormat
                        .formatToParts(x)
                        .map(function (x) { return x.value; })
                        .join('');
                };
                try {
                    // https://github.com/tc39/test262/blob/master/test/intl402/NumberFormat/prototype/format/format-function-name.js
                    Object.defineProperty(boundFormat, 'name', {
                        configurable: true,
                        enumerable: false,
                        writable: false,
                        value: '',
                    });
                }
                catch (e) {
                    // In older browser (e.g Chrome 36 like polyfill.io)
                    // TypeError: Cannot redefine property: name
                }
                internalSlots.boundFormat = boundFormat;
            }
            return boundFormat;
        },
    };
    try {
        // https://github.com/tc39/test262/blob/master/test/intl402/NumberFormat/prototype/format/name.js
        Object.defineProperty(formatDescriptor.get, 'name', {
            configurable: true,
            enumerable: false,
            writable: false,
            value: 'get format',
        });
    }
    catch (e) {
        // In older browser (e.g Chrome 36 like polyfill.io)
        // TypeError: Cannot redefine property: name
    }
    Object.defineProperty(NumberFormat.prototype, 'format', formatDescriptor);
    // Static properties
    defineProperty(NumberFormat, 'supportedLocalesOf', {
        value: function supportedLocalesOf(locales, options) {
            return SupportedLocales(NumberFormat.availableLocales, Intl.getCanonicalLocales(locales), options);
        },
    });
    NumberFormat.__addLocaleData = function __addLocaleData() {
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        for (var _a = 0, data_1 = data; _a < data_1.length; _a++) {
            var datum = data_1[_a];
            var availableLocales = datum.availableLocales;
            for (var _b = 0, availableLocales_1 = availableLocales; _b < availableLocales_1.length; _b++) {
                var locale = availableLocales_1[_b];
                try {
                    NumberFormat.localeData[locale] = unpackData(locale, datum);
                }
                catch (e) {
                    // Ignore if we got no data
                }
            }
        }
        NumberFormat.availableLocales = Object.keys(NumberFormat.localeData);
        if (!NumberFormat.__defaultLocale) {
            NumberFormat.__defaultLocale = NumberFormat.availableLocales[0];
        }
    };
    NumberFormat.__defaultLocale = 'en';
    NumberFormat.localeData = {};
    NumberFormat.availableLocales = [];
    NumberFormat.getDefaultLocale = function () {
        return NumberFormat.__defaultLocale;
    };
    NumberFormat.polyfilled = true;
    /**
     * https://tc39.es/ecma402/#sec-setnumberformatunitoptions
     */
    function setNumberFormatUnitOptions(nf, options) {
        if (options === void 0) { options = Object.create(null); }
        var internalSlots = getInternalSlots(nf);
        var style = GetOption(options, 'style', 'string', ['decimal', 'percent', 'currency', 'unit'], 'decimal');
        internalSlots.style = style;
        var currency = GetOption(options, 'currency', 'string', undefined, undefined);
        if (currency !== undefined && !IsWellFormedCurrencyCode(currency)) {
            throw RangeError('Malformed currency code');
        }
        if (style === 'currency' && currency === undefined) {
            throw TypeError('currency cannot be undefined');
        }
        var currencyDisplay = GetOption(options, 'currencyDisplay', 'string', ['code', 'symbol', 'narrowSymbol', 'name'], 'symbol');
        var currencySign = GetOption(options, 'currencySign', 'string', ['standard', 'accounting'], 'standard');
        var unit = GetOption(options, 'unit', 'string', undefined, undefined);
        if (unit !== undefined && !IsWellFormedUnitIdentifier(unit)) {
            throw RangeError('Invalid unit argument for Intl.NumberFormat()');
        }
        if (style === 'unit' && unit === undefined) {
            throw TypeError('unit cannot be undefined');
        }
        var unitDisplay = GetOption(options, 'unitDisplay', 'string', ['short', 'narrow', 'long'], 'short');
        if (style === 'currency') {
            internalSlots.currency = currency.toUpperCase();
            internalSlots.currencyDisplay = currencyDisplay;
            internalSlots.currencySign = currencySign;
        }
        if (style === 'unit') {
            internalSlots.unit = unit;
            internalSlots.unitDisplay = unitDisplay;
        }
    }
    /**
     * The abstract operation ComputeExponent computes an exponent (power of ten) by which to scale x
     * according to the number formatting settings. It handles cases such as 999 rounding up to 1000,
     * requiring a different exponent.
     *
     * NOT IN SPEC: it returns [exponent, magnitude].
     */
    function computeExponent(numberFormat, x) {
        if (x === 0) {
            return [0, 0];
        }
        if (x < 0) {
            x = -x;
        }
        var magnitude = getMagnitude(x);
        var exponent = computeExponentForMagnitude(numberFormat, magnitude);
        // Preserve more precision by doing multiplication when exponent is negative.
        x = exponent < 0 ? x * Math.pow(10, -exponent) : x / Math.pow(10, exponent);
        var formatNumberResult = FormatNumericToString(getInternalSlots(numberFormat), x);
        if (formatNumberResult.roundedNumber === 0) {
            return [exponent, magnitude];
        }
        var newMagnitude = getMagnitude(formatNumberResult.roundedNumber);
        if (newMagnitude === magnitude - exponent) {
            return [exponent, magnitude];
        }
        return [
            computeExponentForMagnitude(numberFormat, magnitude + 1),
            magnitude + 1,
        ];
    }
    /**
     * The abstract operation ComputeExponentForMagnitude computes an exponent by which to scale a
     * number of the given magnitude (power of ten of the most significant digit) according to the
     * locale and the desired notation (scientific, engineering, or compact).
     */
    function computeExponentForMagnitude(numberFormat, magnitude) {
        var internalSlots = getInternalSlots(numberFormat);
        var notation = internalSlots.notation, dataLocaleData = internalSlots.dataLocaleData, numberingSystem = internalSlots.numberingSystem;
        switch (notation) {
            case 'standard':
                return 0;
            case 'scientific':
                return magnitude;
            case 'engineering':
                return Math.floor(magnitude / 3) * 3;
            default: {
                // Let exponent be an implementation- and locale-dependent (ILD) integer by which to scale a
                // number of the given magnitude in compact notation for the current locale.
                var compactDisplay = internalSlots.compactDisplay, style = internalSlots.style, currencyDisplay = internalSlots.currencyDisplay;
                var thresholdMap = void 0;
                if (style === 'currency' && currencyDisplay !== 'name') {
                    var currency = dataLocaleData.numbers.currency[numberingSystem] ||
                        dataLocaleData.numbers.currency[dataLocaleData.numbers.nu[0]];
                    thresholdMap = currency.short;
                }
                else {
                    var decimal = dataLocaleData.numbers.decimal[numberingSystem] ||
                        dataLocaleData.numbers.decimal[dataLocaleData.numbers.nu[0]];
                    thresholdMap = compactDisplay === 'long' ? decimal.long : decimal.short;
                }
                if (!thresholdMap) {
                    return 0;
                }
                var num = String(Math.pow(10, magnitude));
                var thresholds = Object.keys(thresholdMap); // TODO: this can be pre-processed
                if (num < thresholds[0]) {
                    return 0;
                }
                if (num > thresholds[thresholds.length - 1]) {
                    return thresholds[thresholds.length - 1].length - 1;
                }
                var i = thresholds.indexOf(num);
                if (i === -1) {
                    return 0;
                }
                // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats
                // Special handling if the pattern is precisely `0`.
                var magnitudeKey = thresholds[i];
                // TODO: do we need to handle plural here?
                var compactPattern = thresholdMap[magnitudeKey].other;
                if (compactPattern === '0') {
                    return 0;
                }
                // Example: in zh-TW, `10000000` maps to `0000Ëê¨`. So we need to return 8 - 4 = 4 here.
                return (magnitudeKey.length -
                    thresholdMap[magnitudeKey].other.match(/0+/)[0].length);
            }
        }
    }
    function toNumeric(val) {
        if (typeof val === 'bigint') {
            return val;
        }
        return ToNumber(val);
    }
    try {
        // IE11 does not have Symbol
        if (typeof Symbol !== 'undefined') {
            Object.defineProperty(NumberFormat.prototype, Symbol.toStringTag, {
                configurable: true,
                enumerable: false,
                writable: false,
                value: 'Intl.NumberFormat',
            });
        }
        // https://github.com/tc39/test262/blob/master/test/intl402/NumberFormat/length.js
        Object.defineProperty(NumberFormat.prototype.constructor, 'length', {
            configurable: true,
            enumerable: false,
            writable: false,
            value: 0,
        });
        // https://github.com/tc39/test262/blob/master/test/intl402/NumberFormat/supportedLocalesOf/length.js
        Object.defineProperty(NumberFormat.supportedLocalesOf, 'length', {
            configurable: true,
            enumerable: false,
            writable: false,
            value: 1,
        });
        Object.defineProperty(NumberFormat, 'prototype', {
            configurable: false,
            enumerable: false,
            writable: false,
            value: NumberFormat.prototype,
        });
    }
    catch (e) {
        // Meta fix so we're test262-compliant, not important
    }

    // eslint-disable-next-line import/no-cycle
    /**
     * Number.prototype.toLocaleString ponyfill
     * https://tc39.es/ecma402/#sup-number.prototype.tolocalestring
     */
    function toLocaleString(x, locales, options) {
        var numberFormat = new NumberFormat(locales, options);
        return numberFormat.format(x);
    }

    /**
     * Check if a formatting number with unit is supported
     * @public
     * @param unit unit to check
     */
    function isUnitSupported(unit) {
        try {
            new Intl.NumberFormat(undefined, {
                style: 'unit',
                // @ts-ignore
                unit: unit,
            });
        }
        catch (e) {
            return false;
        }
        return true;
    }
    function shouldPolyfill() {
        return (typeof Intl === 'undefined' ||
            !('NumberFormat' in Intl) ||
            !isUnitSupported('bit'));
    }

    if (shouldPolyfill()) {
        defineProperty(Intl, 'NumberFormat', { value: NumberFormat });
        defineProperty(Number.prototype, 'toLocaleString', {
            value: function toLocaleString$1(locales, options) {
                return toLocaleString(this, locales, options);
            },
        });
    }

})));
//# sourceMappingURL=polyfill.umd.js.map
